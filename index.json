[{"categories":["Frontend"],"content":"在当前项目中 End User License Agreement 是一个静态 XML 文件，在打包在了根目录下直接通过 Angular JS 渲染。 本次开发是升级这个应用为 Angular，并且将其以 Library 的形式引入公司的一个前端的壳内，成为公司整个项目的一个可订阅的功能。 总结需求就是在 Angular 前端工程中获取一个子 Libaray 的静态文件。 ","date":"2022-06-27","objectID":"/posts/%E5%9C%A8-angular-%E7%9A%84-library-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81-xml-%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81-html-%E6%B8%B2%E6%9F%93/:0:0","tags":["Angular"],"title":"在 angular 的 library 中添加静态 XML 作为静态 HTML 渲染","uri":"/posts/%E5%9C%A8-angular-%E7%9A%84-library-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81-xml-%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81-html-%E6%B8%B2%E6%9F%93/"},{"categories":["Frontend"],"content":"单页面获取 XML 的访问权限 第一步要通过 http 就能够直接访问到 xml。http://localhost:4200/eula.xml ","date":"2022-06-27","objectID":"/posts/%E5%9C%A8-angular-%E7%9A%84-library-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81-xml-%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81-html-%E6%B8%B2%E6%9F%93/:1:0","tags":["Angular"],"title":"在 angular 的 library 中添加静态 XML 作为静态 HTML 渲染","uri":"/posts/%E5%9C%A8-angular-%E7%9A%84-library-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81-xml-%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81-html-%E6%B8%B2%E6%9F%93/"},{"categories":["Frontend"],"content":"尝试直接在工程中添加子工程 assets 的目录 项目背景是一个独立的 Windows 程序，本应在这次 release 时进入 docker，成为公司整个软件中的一个订阅，而因为其他项目的延迟保持本项目独立。 也就是说本次 release 我们的前端项目还是一个完整的应用直接进行发布，所以在整个项目的 angular.json 文件中直接为主工程添加子 Library 的静态文件目录，这样未来在删除主项目的时候不会使静态文件丢失。 修改后编译失败，错误如下： An unhandled exception occurred: The projects/…./src/assets asset path must start with the project source root. 也就是说 angular 不允许将 root 目录以外的路径设为资源文件进行编译。那么这个偷懒的方法肯定不行了。 ","date":"2022-06-27","objectID":"/posts/%E5%9C%A8-angular-%E7%9A%84-library-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81-xml-%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81-html-%E6%B8%B2%E6%9F%93/:1:1","tags":["Angular"],"title":"在 angular 的 library 中添加静态 XML 作为静态 HTML 渲染","uri":"/posts/%E5%9C%A8-angular-%E7%9A%84-library-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81-xml-%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81-html-%E6%B8%B2%E6%9F%93/"},{"categories":["Frontend"],"content":"调查目前渲染出来的图片是如何访问的 接下来调查下 angular serve 和 build 后这些 assets 到底在什么地方。 首先，ng serve 起来的 webpack server 中，可以通过根目录直接访问图片文件。devtool 中也可看到，在 localhost：4200 节点下确实有所有的添加在 assets 下面的图片。 以子 Library 的 assets 目录为关键字，在所有代码中搜索发现，子 Library 目录下，有个配置文件 ng-package.json 中面有子 Library 的 assets 的配置。 那么将 XML 文件放到子 Library 中，build 成功，serve 成功。build output 文件中有静态 XML 文件，但是画面无法访问到这个静态文件。 这时想起来我们的子 Library 并不是真个页面的入口，真正渲染的 index 是外面的这个壳，也就是主工程，再次查看 build 结果中主工程的目录结构。 build 根目录下除了主目录的 assets 目录外其他的图片都直接放在了根目录下。 也就是说子 Library 的 assets 下文件都会自动打包到主工程的编译结果的根目录下。但是我添加的 XML 文件就没有被打包进来。 ","date":"2022-06-27","objectID":"/posts/%E5%9C%A8-angular-%E7%9A%84-library-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81-xml-%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81-html-%E6%B8%B2%E6%9F%93/:1:2","tags":["Angular"],"title":"在 angular 的 library 中添加静态 XML 作为静态 HTML 渲染","uri":"/posts/%E5%9C%A8-angular-%E7%9A%84-library-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81-xml-%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81-html-%E6%B8%B2%E6%9F%93/"},{"categories":["Frontend"],"content":"另外一种方式让 webpack 打包 一直没有调查出来 angular 是如何配置才会将子目录的 assets 文件夹内的静态 resources 直接添加到根目录下，猜测这里可能会有个 filter 只添加图片 extension。这里结合前两种方式，直接将子 Library 的文件打包到主工程的根目录下，在 angular.json 的主项目节点的中配置 assets： { \"glob\":\"**/*.xml\", \"input\": \"projects/..your library../src/assets\", \"output\": \"/\" } 这样，XML 文件会被原封不动的打包到主项目的根目录下，暂时先这样解决，回头如果有安全问题再继续调查。 ","date":"2022-06-27","objectID":"/posts/%E5%9C%A8-angular-%E7%9A%84-library-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81-xml-%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81-html-%E6%B8%B2%E6%9F%93/:1:3","tags":["Angular"],"title":"在 angular 的 library 中添加静态 XML 作为静态 HTML 渲染","uri":"/posts/%E5%9C%A8-angular-%E7%9A%84-library-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81-xml-%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81-html-%E6%B8%B2%E6%9F%93/"},{"categories":["Frontend"],"content":"在 innterhtml 指令渲染 XML 此时已经能够通过 http 获取 xml 文件的数据，就通过 Angular 提供的 HttpClient service 来使用 http get 方法来获取 xml 文件内容。 ","date":"2022-06-27","objectID":"/posts/%E5%9C%A8-angular-%E7%9A%84-library-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81-xml-%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81-html-%E6%B8%B2%E6%9F%93/:2:0","tags":["Angular"],"title":"在 angular 的 library 中添加静态 XML 作为静态 HTML 渲染","uri":"/posts/%E5%9C%A8-angular-%E7%9A%84-library-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81-xml-%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81-html-%E6%B8%B2%E6%9F%93/"},{"categories":["Frontend"],"content":"获取 xml 数据 将 HttpClient 注入为 http 后使用如下代码： public elua: Observable\u003cstring\u003e; // ... ngInit(): void { this.eula = this.http.get('eula.xml'); } 报错，这里说 get 的返回值是 Object，不能赋值给 string。 瞅了一眼 get 的描述文件很有意思，这里放下源码： /** * Constructs a `GET` request that interprets the body as a JSON object and * returns the response body as a JSON object. * * @param url The endpoint URL. * @param options The HTTP options to send with the request. * * * @return An `Observable` of the response body as a JSON object. */ get(url: string, options?: { headers?: HttpHeaders|{[header: string]: string | string[]}, context?: HttpContext, observe?: 'body', params?: HttpParams| {[param: string]: string | number | boolean | ReadonlyArray\u003cstring|number|boolean\u003e}, reportProgress?: boolean, responseType?: 'json', withCredentials?: boolean, }): Observable\u003cObject\u003e; 需要将 options 的 responseType 属性设置为 text，get 的返回值就是 string 类型了。 ","date":"2022-06-27","objectID":"/posts/%E5%9C%A8-angular-%E7%9A%84-library-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81-xml-%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81-html-%E6%B8%B2%E6%9F%93/:2:1","tags":["Angular"],"title":"在 angular 的 library 中添加静态 XML 作为静态 HTML 渲染","uri":"/posts/%E5%9C%A8-angular-%E7%9A%84-library-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81-xml-%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81-html-%E6%B8%B2%E6%9F%93/"},{"categories":["Frontend"],"content":"TypeScript 通过类型减少错误 这里印象中 http 的返回值应该是个 any 的 response，因为 http service 并不知道用户请求的是什么，他可能是任何东西。 上下翻阅可以发现相关的 get 方法的重载，返回值通过形参 options 的 responseType 来决定。 github httpclient get 的实际实现果然还是直接用 any 返回，但是这样的描述文件就能达到字符串配置来控制返回值，这在类型安全中是非常实用的，如果不配置正确的 options，就不会得到正确的返回值，而这个错误不用在 runtime 中去解决，而在编译时就能够发现。 尝试自己写一个这样的 typescript 例子： class DeleteResult { public deleteData: any; } class UpdateResult { public updateData: any; } class InsertResult { public insertData: any; } class Tester { doAction(options: { action: 'delete' }): DeleteResult; doAction(options: { action: 'update' }): UpdateResult; doAction(options: { action: 'insert' }): InsertResult; doAction(options: IOptions): any { if (options.action === 'delete') return new DeleteResult(); if (options.action === 'update') return new UpdateResult(); if (options.action === 'insert') return new InsertResult(); } } interface IOptions { action: 'delete' | 'update' | 'insert'; } let tester = new Tester(); let deleteResult: DeleteResult = tester.doAction({ action: 'delete' }); // error: Property 'insertData' is missing in type 'DeleteResult' but required in type 'InsertResult'. let insertResult: InsertResult = tester.doAction({ action: 'delete' }); 这里如果三个类型都是空对象就不会报错，编译器会自动判断他们的类型是一样的，都是没有属性的空对象，所以类型可以互相转换。 未来拓展可以尝试用这个特性来做异常处理。 ","date":"2022-06-27","objectID":"/posts/%E5%9C%A8-angular-%E7%9A%84-library-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81-xml-%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81-html-%E6%B8%B2%E6%9F%93/:2:2","tags":["Angular"],"title":"在 angular 的 library 中添加静态 XML 作为静态 HTML 渲染","uri":"/posts/%E5%9C%A8-angular-%E7%9A%84-library-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81-xml-%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81-html-%E6%B8%B2%E6%9F%93/"},{"categories":["All In One Server"],"content":"使用 LEDE 不使用原版包，嫌弃折腾插件费劲。 ","date":"2022-04-14","objectID":"/posts/openwrt-%E7%BC%96%E8%AF%91%E4%B8%8E%E5%AE%89%E8%A3%85/:0:0","tags":["OpenWrt"],"title":"OpenWrt 编译以及 ESXI 虚拟机宿主环境安装","uri":"/posts/openwrt-%E7%BC%96%E8%AF%91%E4%B8%8E%E5%AE%89%E8%A3%85/"},{"categories":["All In One Server"],"content":"安装编译依赖 安装全部依赖 sudo apt-get -y install build-essential asciidoc binutils bzip2 gawk gettext git libncurses5-dev libz-dev patch python3 python2.7 unzip zlib1g-dev lib32gcc1 libc6-dev-i386 subversion flex uglifyjs git-core gcc-multilib p7zip p7zip-full msmtp libssl-dev texinfo libglib2.0-dev xmlto qemu-utils upx libelf-dev autoconf automake libtool autopoint device-tree-compiler g++-multilib antlr3 gperf wget curl swig rsync 找个编译目录拉取代码 git clone https://github.com/coolsnowwolf/lede.git openwrt 无脑给全部权限，注意不要使用 root 账号 make chmod -R 777 openwrt ","date":"2022-04-14","objectID":"/posts/openwrt-%E7%BC%96%E8%AF%91%E4%B8%8E%E5%AE%89%E8%A3%85/:1:0","tags":["OpenWrt"],"title":"OpenWrt 编译以及 ESXI 虚拟机宿主环境安装","uri":"/posts/openwrt-%E7%BC%96%E8%AF%91%E4%B8%8E%E5%AE%89%E8%A3%85/"},{"categories":["All In One Server"],"content":"编译配置 工程根目录 feeds.conf.default 文件配置源，添加如下 git 源： src-git kenzo https://github.com/kenzok8/openwrt-packages src-git passwall https://github.com/xiaorouji/openwrt-passwall 执行： ./scripts/feeds update -a \u0026\u0026 ./scripts/feeds install -a 想要的京东签到包需要手动添加： cd package/lean/ git clone https://github.com/jerrykuku/luci-app-jd-dailybonus.git 上面的 feeds 配置执行的脚本实际上就是将 github 包的源文件下载到这个目录中。 执行 make menuconfig 的时候就可以看到，他会将所有的包源文件集中到图形界面去配置。 ","date":"2022-04-14","objectID":"/posts/openwrt-%E7%BC%96%E8%AF%91%E4%B8%8E%E5%AE%89%E8%A3%85/:2:0","tags":["OpenWrt"],"title":"OpenWrt 编译以及 ESXI 虚拟机宿主环境安装","uri":"/posts/openwrt-%E7%BC%96%E8%AF%91%E4%B8%8E%E5%AE%89%E8%A3%85/"},{"categories":["All In One Server"],"content":"镜像使用 编译生成的 vmdk 文件没有使用成功，所以还是使用 img 转成 vmdk 使用。 mac 安装 qemu 会带 qemu-img 工具包： qemu-img convert -f raw openwrt_o.img -O vmdk openwrt_o.vmdk 将其转化为 vmdk 后上传到 ESXI 中，并通过 ssh 访问对应的实际路径找到该文件，使用 vmkfstools 将其再次转换为 ESXI 可以使用的虚拟磁盘： vmkfstools -i openwrt_o.vmdk -d thin openwrt.vmdk 删除原来的 vmdk 磁盘就可以正常使用了。 ","date":"2022-04-14","objectID":"/posts/openwrt-%E7%BC%96%E8%AF%91%E4%B8%8E%E5%AE%89%E8%A3%85/:3:0","tags":["OpenWrt"],"title":"OpenWrt 编译以及 ESXI 虚拟机宿主环境安装","uri":"/posts/openwrt-%E7%BC%96%E8%AF%91%E4%B8%8E%E5%AE%89%E8%A3%85/"},{"categories":["All In One Server"],"content":"原因是 iframe 中 hardcode 访问 http 协议。 直接通过 nginx 服务器反向代理添加于 OpenWrt 相同 SSL 证书解决。 ","date":"2022-04-10","objectID":"/posts/openwrt-%E6%B7%BB%E5%8A%A0-ssl-%E8%AF%81%E4%B9%A6%E5%90%8E-netdata-%E5%92%8C-ttyd-%E6%8B%92%E7%BB%9D%E8%AF%B7%E6%B1%82/:0:0","tags":["OpenWrt"],"title":"OpenWrt 添加 SSL 证书后 NetData 和 TTYD 拒绝请求","uri":"/posts/openwrt-%E6%B7%BB%E5%8A%A0-ssl-%E8%AF%81%E4%B9%A6%E5%90%8E-netdata-%E5%92%8C-ttyd-%E6%8B%92%E7%BB%9D%E8%AF%B7%E6%B1%82/"},{"categories":["All In One Server"],"content":"添加 SSL 证书 vim /etc/nginx/sites-available/netdata server { listen 19999 ssl; server_name domain; ssl_certificate 【pem 证书】; ssl_certificate_key 【key】; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { proxy_pass http://192.168.50.1:19999/ proxy_set_header Host $host; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection upgrade; proxy_set_header Accept-Encoding gzip; } } 添加 link 到 enabled 路径时注意不要使用相对路径： ln -s /etc/nginx/sites-available/netdata /etc/nginx/sites-enabled/netdata nginx -t 验证后重启 nginx 服务 service nginx restart 路由器映射 nginx 服务器 19999 端口后测试能否使用 https 协议域名访问 NetData。 ","date":"2022-04-10","objectID":"/posts/openwrt-%E6%B7%BB%E5%8A%A0-ssl-%E8%AF%81%E4%B9%A6%E5%90%8E-netdata-%E5%92%8C-ttyd-%E6%8B%92%E7%BB%9D%E8%AF%B7%E6%B1%82/:1:0","tags":["OpenWrt"],"title":"OpenWrt 添加 SSL 证书后 NetData 和 TTYD 拒绝请求","uri":"/posts/openwrt-%E6%B7%BB%E5%8A%A0-ssl-%E8%AF%81%E4%B9%A6%E5%90%8E-netdata-%E5%92%8C-ttyd-%E6%8B%92%E7%BB%9D%E8%AF%B7%E6%B1%82/"},{"categories":["All In One Server"],"content":"修改静态 html 根目录下搜索路由 netdata 找到对应静态 html： find / -name netdata 搜索到有以下两个路径： /rom/usr/lib/lua/luci/view/netdata /usr/lib/lua/luci/view/netdata rom 目录是用来 reset 使用的，如果想 reset 时候也保持修改，可以同时修改两处。 进入目录 /usr/lib/lua/luci/view/netdata 后就能看到静态的 ‘netdata.htm’。 有需求 http 访问的可以通过 document.location.protocol 判断协议，再给目标 url 赋值。 修改 iframe hardcode 的 protocol 和 端口号： if(document.location.protocol.indexOf('https')\u003e-1){ document.getElementById(\"netdata\").src = \"https://\" + window.location.hostname + \":8134\"; } else { document.getElementById(\"netdata\").src = \"http://\" + window.location.hostname + \":19999\"; } OK 刷新画面搞定。 ","date":"2022-04-10","objectID":"/posts/openwrt-%E6%B7%BB%E5%8A%A0-ssl-%E8%AF%81%E4%B9%A6%E5%90%8E-netdata-%E5%92%8C-ttyd-%E6%8B%92%E7%BB%9D%E8%AF%B7%E6%B1%82/:2:0","tags":["OpenWrt"],"title":"OpenWrt 添加 SSL 证书后 NetData 和 TTYD 拒绝请求","uri":"/posts/openwrt-%E6%B7%BB%E5%8A%A0-ssl-%E8%AF%81%E4%B9%A6%E5%90%8E-netdata-%E5%92%8C-ttyd-%E6%8B%92%E7%BB%9D%E8%AF%B7%E6%B1%82/"},{"categories":["All In One Server"],"content":"最后 还用什么 uhttpd，直接全部 nginx 代理。 ","date":"2022-04-10","objectID":"/posts/openwrt-%E6%B7%BB%E5%8A%A0-ssl-%E8%AF%81%E4%B9%A6%E5%90%8E-netdata-%E5%92%8C-ttyd-%E6%8B%92%E7%BB%9D%E8%AF%B7%E6%B1%82/:3:0","tags":["OpenWrt"],"title":"OpenWrt 添加 SSL 证书后 NetData 和 TTYD 拒绝请求","uri":"/posts/openwrt-%E6%B7%BB%E5%8A%A0-ssl-%E8%AF%81%E4%B9%A6%E5%90%8E-netdata-%E5%92%8C-ttyd-%E6%8B%92%E7%BB%9D%E8%AF%B7%E6%B1%82/"},{"categories":["All In One Server"],"content":"到 IPv6 自动获取时会卡住 ctrl+c 退出这一步，重新改成手动配置网络 ","date":"2022-03-26","objectID":"/posts/openmediavault/:0:0","tags":["OpenMediaVault"],"title":"解决 OpenMediaVault 安装卡住","uri":"/posts/openmediavault/"},{"categories":["Personal Insights Essays"],"content":"自 2021.5.31 进入罗克韦尔至今，刚好六个月，算是我前半年的成果。跳出了外包之后大开眼界，体会两个完全不同的软件行业，半年时间看看我都做了什么，我都成长了哪些，有哪些需要改进，有哪些需要反复咀嚼。 ","date":"2021-11-02","objectID":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/:0:0","tags":["个人感悟"],"title":"进入 RA 半年总结","uri":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/"},{"categories":["Personal Insights Essays"],"content":"我做了什么 主业和业余都做了什么，钱都花在了哪里。 ","date":"2021-11-02","objectID":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/:1:0","tags":["个人感悟"],"title":"进入 RA 半年总结","uri":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/"},{"categories":["Personal Insights Essays"],"content":"主业 除去个别调查以下是这半年来所有的任务： 刚来单位疏通代码，足部能够完成开发 Manage Favorite 功能简单实现 Node Server 重构 总结评估目前完成的两个画面的 anomaly Electron 和 Node Server 打包 分析和重构多刷逻辑 ","date":"2021-11-02","objectID":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/:1:1","tags":["个人感悟"],"title":"进入 RA 半年总结","uri":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/"},{"categories":["Personal Insights Essays"],"content":"业余 大多数围绕自己家庭服务器展开扩展： HomeAssistant 智能家居搭配 zigbee 自制网关实现连接低价 zigbee 设备 ESXI 添加路由和 docker jenkins 服务器 ","date":"2021-11-02","objectID":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/:1:2","tags":["个人感悟"],"title":"进入 RA 半年总结","uri":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/"},{"categories":["Personal Insights Essays"],"content":"读书 《这本书能让你睡得好》《人性实验》《第一本 Docker 书》《大话设计模式》《编写可读代码的艺术》《九型人格：发现最好的自己》《重要的事，只有一件》《你真的会写代码吗》 只有《重要的事，只有一件》《编写可读代码的艺术》读完，《第一本 Docker 书》以工具书工具书的方式阅览。 ","date":"2021-11-02","objectID":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/:1:3","tags":["个人感悟"],"title":"进入 RA 半年总结","uri":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/"},{"categories":["Personal Insights Essays"],"content":"购买订阅 Medium 一年 300+ 梯子 30 一个月 Anki 168 终身 Kindle 换 iPad mini 加平替笔 noteability \u0026 good notes Mweb 英语每节课 12 ","date":"2021-11-02","objectID":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/:1:4","tags":["个人感悟"],"title":"进入 RA 半年总结","uri":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/"},{"categories":["Personal Insights Essays"],"content":"自我评估 从后往前分析。 ","date":"2021-11-02","objectID":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/:2:0","tags":["个人感悟"],"title":"进入 RA 半年总结","uri":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/"},{"categories":["Personal Insights Essays"],"content":"购买订阅 梯子离不开值得花。 Anki 之前一直使用别人的账号下了一个版本，能够坚持长期使用，值得投资，能够获取每次更新优化算法。 Medium 年缴，打算的是每天读外文博文，学习一些技术锻炼英语。但是坚持的不久，还是读书是长久之计。而且热衷于偏技术浅层的文章，都是一些语言的特性和框架的使用，并不利于境界的提升，而单词没有复习重复使用也没有背下来什么。 Kindle 护眼，但是确实没 iPad 方便，换成 iPad 不但可以随意读各种书籍，也能方便使用自己的工具链。 noteability \u0026 good notes，用的不多，但是用的时候真的方便，一次投资终身可用。 Mweb 用来管理我的所有文档很方便，电脑和 iPad 可以相互同步，尤其前天 Typora 开始年费订阅，就显得更有价值，唯一的劣势是没有 windows 的支持。 英语课是我现在口语输出的最大方式，与老师关系良好，价钱不是很贵，但是目前很难找到一个值得使用的学习教材，学到的单词很难复用就会遗忘。这部分只能通过 Anki 来弥补，所以不可以偷懒，学习过的单词一定要整理成 Anki card 来辅助练习。今后哪怕别的牌组里面有的词也应该提前进行学习，因为正好遇见了会有重复使用的可能。 ","date":"2021-11-02","objectID":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/:2:1","tags":["个人感悟"],"title":"进入 RA 半年总结","uri":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/"},{"categories":["Personal Insights Essays"],"content":"读书 在读工具书的时候还好，过一遍只是为了未来更快的定位自己的查询目标。遇到一些值得执行的内容可以直接标注下来进行代码的重构。 读其他书有一个很大的问题，读过的书没什么印象。之前读的权威指南是会自己翻译一遍，校验一遍，提取中文一遍，再总结成自己的脑图一遍。而目前大都只是读一遍，我并没有读一遍能达到很好效果的读书能力，所以度过的书基本没有什么印象了。我过多的将 effort 放在了学习的准备中，为了排列重要的事我又花了两周多的时间使用一个开源 kanban 来替换 worklite。我的确准备做读书笔记的内容记录了下来，但是并没有形成之前多次阅读和总结的效果。所以，遇到真正需要学习的书，要像读课本一样去学习，粗读，细读，复习，自己写。 再有选书的时候有四点值得注意。第一《人性实验》里的实验的确能够让人看清楚人类的一些本质，但是如果想利用这些黑暗的本质缺很难，也就是说对目前的急需提高的我选书需要看清楚是否性价比高，能够直接提升我想要完成的最重要的事的书，是我现在需要阅读的。第二《这本书能让你睡得好》，书没问题，人能否做到，我是个经常因为各种事情无法规律的人，不改变这些读这本书也没有意义，曾经罗列的几点现在能记住的都没有执行过，这也是一种浪费时间。第三《九型人格：发现最好的自己》,读九型人格是领导的建议，在关于我自身的一些问题确实很准，但是这本书选书时候过于粗糙，并不是一本流行版本，是国内一个作者写的，错字连篇废话连篇，也导致最后没有读完，反而放弃了对九型人格的更多的学习。第四与我读 Medium 的博文特点一致，过多关注的技术书籍大多是有关程序员最表层的内容，优化代码相关，而应该更多的去学习能够提高境界的书籍。 ","date":"2021-11-02","objectID":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/:2:2","tags":["个人感悟"],"title":"进入 RA 半年总结","uri":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/"},{"categories":["Personal Insights Essays"],"content":"业余 业余内做的都是个人爱好，花费了大量的时间去准备自己的学习环境家庭环境，但是往往使用机会并不多，也就是投入产出比不成正比。或许更多的投入读书和英语的学习回报会更大。 ","date":"2021-11-02","objectID":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/:2:3","tags":["个人感悟"],"title":"进入 RA 半年总结","uri":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/"},{"categories":["Personal Insights Essays"],"content":"主业 目前来看，主业的技术方面我能够适应变化，在调查不熟知领域时还能够胜任。 但是在阅读原来代码很困难，有以下几种可能： 原来代码的架构耦合度太高，层次太多 我阅读别人代码的能力太差，确实做的 review 相关工作不是特别多 不了解领域知识，对于公司的业务所知甚少 总结下最近学习到的东西 以下根据平时别人的指正及时记录下来的一些问题坐下总结。 代码质量方面 减少 any script，减少测试风险，有类型检验不会导致误写。 防止写完了的代码记不住，通过命名和类型辅助理解代码。写的代码要有语义。 方法名要根据方法的作用是什么。 写代码要给别人看的懂，类型不但能够减少 bug 风险也能有助于理解代码。 代码要有依赖关系，减少使用弱类型特性也就是减少。 有接口一定要实现，如果实现与接口参数不一致，层次肯定有问题。 ng 生命周期钩子要 implement，不然代码仍然没有依赖。 重视不同层次（class）之间的关系（依赖），不用过多考虑私有成员的关系。 接口与依赖能够帮助理解代码，也能正确的建立领域模型。就像这回调查旧代码的多刷逻辑，不应该逐行弄懂每个数据的来源，而应该从整个领域模型来猜测要执行这个逻辑操作我我需要调用者给我什么（接口），我需要服务为我提供哪些（依赖），调用者需要我提供什么（返回值）。首先应该能明确这些模型框架，然后才是里面细致的逻辑。 封装一个组件时，不同的使用场景只会使用部分业务，这样的组件就不要封装成一个。 从业务上发现奇怪的东西，比如业务上是一个东西，却写了两部分去实现。 在一个组件中放了两个相同的 grid，虽然是为了实现两个不同业务的 grid，但是很奇怪。 结合领域业务来分析代码，业务上需要一个实例有两个表现方式，那业务的实现上我们就不应该使用两个实例来分别表现这个业务上的实例。 错误不要提前处理成正常值，要暴漏出来，最后统一处理。 异常不需要提前处理，这些东西不到最后不会想到一个完美的解决方案，前期我们无法知道到底什么是好什么是坏，所以放在最后，包括一些风格统一的问题，最后尽量借助工具来解决。 管理方面 面对批评不要第一时间拒绝。 想要做的事如果做了就要做到最好，不然依然是反例。 做事一定要细，反观同事就敲一行指令都会 check 两遍。不然最后功亏一篑。要记得先读 readme。 关注点不应该是是否节约工时，因为没进行双盲测试，无法知道效率是否真的提高。应该侧重于这个问题点是否是开发的绊脚石。 提高的重点是如何提高质量较少错误，从架构上和技术上取实现错误的减少。比如 typescript。 加快开发的方式应该是如何想办法自动化想办法减少 bug 的产生。 不要有自己改动别人代码的想法，一定要得到认可，让别人自己改。 尽可能少的取改代码，如果改要看能否将改动范围缩小在自己的代码中。或者能够不影响别人的情况下一点一点渗透。新的修改一定要兼容旧的代码。 声望和名誉是需要累积的，如果没有声望的条件最好私下里每个人都得到认同，或者得到某些人的肯定后连带署名。 如果不能说服别人的设计可能在别人看来就不是个好的设计，要提高自己的语言能力。 没有对错只有合适不合适。每个人职位不同，关注点是不同的，测试和开发完全是两个思维。要吃透每一个人。 与测试人员沟通要用对方的角度去思考，开发的方式沟通他们不懂，也不要教他们，他们的工作不需要这些知识，只需要掌握是否可以在不影响语义和代码逻辑的条件下满足他们的需求即可。 与不同领域的人沟通要以对方或者共通的模型来进行沟通。 ","date":"2021-11-02","objectID":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/:2:4","tags":["个人感悟"],"title":"进入 RA 半年总结","uri":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/"},{"categories":["Personal Insights Essays"],"content":"结论与计划 ","date":"2021-11-02","objectID":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/:3:0","tags":["个人感悟"],"title":"进入 RA 半年总结","uri":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/"},{"categories":["Personal Insights Essays"],"content":"业余读书与订阅 倾向于高性价比方向，提高急需的技术和业务知识，遵从以下选购方向： 能够长期使用伴随整个职业生涯 能够直接提高自己的工作与生活 选择的时候要观察是否权威 ","date":"2021-11-02","objectID":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/:3:1","tags":["个人感悟"],"title":"进入 RA 半年总结","uri":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/"},{"categories":["Personal Insights Essays"],"content":"读书方式改变 不再概览，我的能力需要按照上课的方式一章一节掌握再继续。上面精选出来的书要按照以下方式阅读： 章节阅读与笔记 章节目录阅览 总结笔记 回想章节自己以任何一种方式描述出来 从现在开始不求快只求稳求得到。 ","date":"2021-11-02","objectID":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/:3:2","tags":["个人感悟"],"title":"进入 RA 半年总结","uri":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/"},{"categories":["Personal Insights Essays"],"content":"工作的计划与改变 需要尽快提高对业务的掌握，才能更容易读懂旧代码： 阅读公司各种软件产品的帮助文档 询问身边的测试专家，他们的领域业务极强 工作注意： 细，一定要细 一定要弄任务需求，弄懂敏捷开发不断更新的这种方式 ","date":"2021-11-02","objectID":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/:3:3","tags":["个人感悟"],"title":"进入 RA 半年总结","uri":"/posts/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/"},{"categories":["All In One Server"],"content":" Win 与 Ctrl 对调 ","date":"2021-11-02","objectID":"/posts/windows-%E8%AE%BE%E7%BD%AE/:0:0","tags":["Windows"],"title":"Windows 注册表修改键盘映射","uri":"/posts/windows-%E8%AE%BE%E7%BD%AE/"},{"categories":["All In One Server"],"content":"用于一些自己写的智能家居服务和开源项目。 ","date":"2021-10-30","objectID":"/posts/ubuntu-server/:0:0","tags":["Ubuntu"],"title":"Ubuntu server","uri":"/posts/ubuntu-server/"},{"categories":["All In One Server"],"content":"Ubuntu 安装 安装时以下个人配置 ","date":"2021-10-30","objectID":"/posts/ubuntu-server/:1:0","tags":["Ubuntu"],"title":"Ubuntu server","uri":"/posts/ubuntu-server/"},{"categories":["All In One Server"],"content":"静态 IP name servers 没有添加，导致系统无法解析域名。 /etc/netplan/00-installer-config.yaml 文件用来配置网络 ","date":"2021-10-30","objectID":"/posts/ubuntu-server/:1:1","tags":["Ubuntu"],"title":"Ubuntu server","uri":"/posts/ubuntu-server/"},{"categories":["All In One Server"],"content":"分区 默认分配一半空间给 root 和 boot，留一半 free space，重新分区。 防止未来编译内核，给 boot 10 个 G。 ","date":"2021-10-30","objectID":"/posts/ubuntu-server/:1:2","tags":["Ubuntu"],"title":"Ubuntu server","uri":"/posts/ubuntu-server/"},{"categories":["All In One Server"],"content":"额外服务 直接打开 open ssh server 安装时可以使用 snap 安装 nextcloud 和 docker，但是 docker 使用中有一些问题，留着自己安装。 ","date":"2021-10-30","objectID":"/posts/ubuntu-server/:1:3","tags":["Ubuntu"],"title":"Ubuntu server","uri":"/posts/ubuntu-server/"},{"categories":["All In One Server"],"content":"Samba service 安装 sudo apt install samba samba-common 创建目录配置权限 mkdir /home/volumes chown nobody:nogroup /home/volumes chmod 777 /home/volumes 配置 /etc/samba/smb.conf vim /etc/samba/smb.conf [Volumes] comment = TimeCapsule Volumes path = /home/ten/openwrt/bin browseable = yes writable = yes available = yes valid users = [a user name] 添加用户 smbpasswd -a [a user name] 重启服务 sudo service smbd restart ","date":"2021-10-30","objectID":"/posts/ubuntu-server/:2:0","tags":["Ubuntu"],"title":"Ubuntu server","uri":"/posts/ubuntu-server/"},{"categories":["All In One Server"],"content":"docker 安装 首先清理 docker sudo apt-get remove docker docker-engine docker.io containerd runc 安装 sudo apt-get update sudo apt-get install \\ ca-certificates \\ curl \\ gnupg \\ lsb-release curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg echo \\ \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io ","date":"2021-10-30","objectID":"/posts/ubuntu-server/:3:0","tags":["Ubuntu"],"title":"Ubuntu server","uri":"/posts/ubuntu-server/"},{"categories":["All In One Server"],"content":"安装 LMS 提供 airplay 给 HA 使用了别人的 docker compose wget https://www.justplus.com.tw/uploads/7/6/7/0/76706939/docker-compose_lms.yml.zip 解压 安装 docker-compose docker-compose up -d ","date":"2021-10-30","objectID":"/posts/ubuntu-server/:4:0","tags":["Ubuntu"],"title":"Ubuntu server","uri":"/posts/ubuntu-server/"},{"categories":["All In One Server"],"content":"code server 以 code server 为例，部署 docker 项目的项目。 ","date":"2021-10-30","objectID":"/posts/ubuntu-server/:5:0","tags":["Ubuntu"],"title":"Ubuntu server","uri":"/posts/ubuntu-server/"},{"categories":["All In One Server"],"content":"docker compose 部署 docker-compose.yml --- version: \"2.1\" services: code-server: image: lscr.io/linuxserver/code-server container_name: code-server environment: - PUID=1000 - PGID=1000 - TZ=Asia/Shanghai - PASSWORD= #optional - HASHED_PASSWORD= #optional - SUDO_PASSWORD= #optional - SUDO_PASSWORD_HASH= #optional - PROXY_DOMAIN=https:code.2019919.xyz #optional volumes: - /home/volumes/code_server:/config #直接将其文件放在SMB路径下，方便管理 ports: - 8082:8443 restart: unless-stopped docker-compose up -d ","date":"2021-10-30","objectID":"/posts/ubuntu-server/:5:1","tags":["Ubuntu"],"title":"Ubuntu server","uri":"/posts/ubuntu-server/"},{"categories":["All In One Server"],"content":"nginx 代理 https 安装 nginx apt-get install nginx 上传证书 直接将证书目录指定到 SMB 共享目录的 ssl 下方便每年维护 创建配置文件 进入可用网站配置目录 /etc/nginx/sites-available，新建一个code-server文件 vi code-server 添加以下内容 server { # 填写nginx向公网开放的端口 listen 8083 ssl; # 填写SSL证书对应的域名 server_name domain; # SSL证书文件，请替换成对应的绝对路径和文件名 ssl_certificate /home/volumes/ssl/2021.pem; # SSL证书密钥文件，请替换成对应的绝对路径和文件名 ssl_certificate_key /home/volumes/ssl/2021.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { # 填写nginx代理的本地端口，请把端口替换成上面code-server配置的实际端口 proxy_pass http://localhost:8082/; proxy_set_header Host $host; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection upgrade; proxy_set_header Accept-Encoding gzip; } # 使用497状态码检测HTTP请求，自动转换为HTTPS error_page 497 https://$host:$server_port$uri$is_args$args; } 应用配置 cd /etc/nginx # 把可用网站配置目录中的 code-server 配置拷贝到已启用网站配置目录 cp sites-available/code-server sites-enabled/code-server # 删除已启用网站配置目录中的默认网站配置 rm sites-enabled/default # 检查配置文件是否存在错误，不知道为啥软连接过来的文件显示不存在 sudo nginx -t # 重新加载配置文件 sudo nginx -s reload # 重启 nginx 服务 sudo systemctl restart nginx OK，Https 访问。 回头 electron 打包给 win mac ipadOS。 ","date":"2021-10-30","objectID":"/posts/ubuntu-server/:5:2","tags":["Ubuntu"],"title":"Ubuntu server","uri":"/posts/ubuntu-server/"},{"categories":["All In One Server"],"content":"mongoDB docker pull mongo 将文件挂载到共享目录 docker run -p 27017:27017 -v /home/volumes/mongo:/data/db --name mongodb -d mongo # Use root/example as user/password credentialsversion:'3.1'services:mongo:image:mongorestart:alwaysports:- 27017:27017environment:MONGO_INITDB_ROOT_USERNAME:rootMONGO_INITDB_ROOT_PASSWORD:examplevolumes:# folder where lms stores its data (cache, logs, prefs)- /home/volumes/mongo:/data/dbmongo-express:image:mongo-expressrestart:alwaysports:- 8084:8081environment:ME_CONFIG_MONGODB_ADMINUSERNAME:rootME_CONFIG_MONGODB_ADMINPASSWORD:exampleME_CONFIG_MONGODB_URL:mongodb://root:example@mongo:27017/","date":"2021-10-30","objectID":"/posts/ubuntu-server/:6:0","tags":["Ubuntu"],"title":"Ubuntu server","uri":"/posts/ubuntu-server/"},{"categories":["Reading"],"content":"可以作为工具书使用 摘录一下目前我需要经常遇到的一些 cli ","date":"2021-10-30","objectID":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC-docker-%E4%B9%A6/:0:0","tags":["读书笔记"],"title":"我的第一本 Docker 书","uri":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC-docker-%E4%B9%A6/"},{"categories":["Reading"],"content":"docker 启动停止 ","date":"2021-10-30","objectID":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC-docker-%E4%B9%A6/:1:0","tags":["读书笔记"],"title":"我的第一本 Docker 书","uri":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC-docker-%E4%B9%A6/"},{"categories":["Reading"],"content":"docker run docker run 命令，并指定了 -i 和 -t 两个命令行参数。 -i 标志保证容器中 STDIN 是开启的，尽管我们并没有附着到容器中。持久的标准输入是交互式 shell 的“半边天”， -t 标志则是另外“半边天”，它告诉 Docker 为要创建的容器分配一个伪 tty 终端。 docker run -i -t image_name /bin/bash ","date":"2021-10-30","objectID":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC-docker-%E4%B9%A6/:1:1","tags":["读书笔记"],"title":"我的第一本 Docker 书","uri":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC-docker-%E4%B9%A6/"},{"categories":["Reading"],"content":"docker start 开启容器 docker start container_name ","date":"2021-10-30","objectID":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC-docker-%E4%B9%A6/:1:2","tags":["读书笔记"],"title":"我的第一本 Docker 书","uri":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC-docker-%E4%B9%A6/"},{"categories":["Reading"],"content":"docker attach 附着容器，就是退出容器后再进入 docker attach container_name ","date":"2021-10-30","objectID":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC-docker-%E4%B9%A6/:1:3","tags":["读书笔记"],"title":"我的第一本 Docker 书","uri":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC-docker-%E4%B9%A6/"},{"categories":["Reading"],"content":"daemonized container 守护式容器（ daemonized container ）没有交互式会话，非常适合运行应用程序和服务。 docker run –name daemon_dave -d ubuntu /bin/sh -d 会在后台运行 ","date":"2021-10-30","objectID":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC-docker-%E4%B9%A6/:1:4","tags":["读书笔记"],"title":"我的第一本 Docker 书","uri":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC-docker-%E4%B9%A6/"},{"categories":["Reading"],"content":"docker stop 停止容器 docker stop 命令会向 Docker 容器进程发送 SIGTERM 信号。如果想快速停止某个容器，也可以使用 docker kill 命令来向容器进程发送 SIGKILL 信号。 docker stop container_name docker kill container_name ","date":"2021-10-30","objectID":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC-docker-%E4%B9%A6/:1:5","tags":["读书笔记"],"title":"我的第一本 Docker 书","uri":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC-docker-%E4%B9%A6/"},{"categories":["Reading"],"content":"restart 设置重启条件 设置重启条件 docker run –restart=always –name daemon_dave -d ubuntu /bin/bash -c “while true; do echo hello world; sleep 1; done” ","date":"2021-10-30","objectID":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC-docker-%E4%B9%A6/:1:6","tags":["读书笔记"],"title":"我的第一本 Docker 书","uri":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC-docker-%E4%B9%A6/"},{"categories":["Reading"],"content":"DockerFile ","date":"2021-10-30","objectID":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC-docker-%E4%B9%A6/:2:0","tags":["读书笔记"],"title":"我的第一本 Docker 书","uri":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC-docker-%E4%B9%A6/"},{"categories":["Reading"],"content":"DockerFile 每条指令都是大写字母，而且后面都会跟随一个参数 EXPOSE 指令向外部开放多个端口 RUN命令执行命令并创建新的镜像层，通常用于安装软件包 CMD命令设置容器启动后默认执行的命令及其参数，但CMD设置的命令能够被docker run命令后面的命令行参数替换 ENTRYPOINT配置容器启动时的执行命令（不会被忽略，一定会被执行，即使运行 docker run时指定了其他命令） ","date":"2021-10-30","objectID":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC-docker-%E4%B9%A6/:2:1","tags":["读书笔记"],"title":"我的第一本 Docker 书","uri":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC-docker-%E4%B9%A6/"},{"categories":["Reading"],"content":"开放端口 用 docker ps 命令来看一下容器的端口分配情况，docker port static_web 80 0.0.0.0:49154。 docker run -d -p 80:80 宿主机 端口在前。 Docker 还提供了一个更简单的方式，即 -P 参数，该参数可以用来对外公开在 Dockerfile 中通过 EXPOSE 指令公开的所有端口。 ","date":"2021-10-30","objectID":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC-docker-%E4%B9%A6/:2:2","tags":["读书笔记"],"title":"我的第一本 Docker 书","uri":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC-docker-%E4%B9%A6/"},{"categories":["All In One Server"],"content":"ESXI 不要修改 dispaly name，防止重启找不到 vmdk 管理口注意需要在 ESXI 中设置混淆 ","date":"2021-10-14","objectID":"/posts/openwrt/:0:0","tags":["OpenWrt"],"title":"OpenWrt 初识记录","uri":"/posts/openwrt/"},{"categories":["All In One Server"],"content":"安装 创建 3.x Linux 64位 虚拟机 给预留内存以便于硬件直通 对应的网口硬件号是 2 3 4 5 网口直通： eth0：Control eth1：NAS eth2：LAN eth3：WAN 创建目录上传 vmdk，使用 self 精简版镜像。 选择 BIOS 引导镜像，防止 UEFI 未来需要修改硬盘大小。 启动设置密码。 注意 设置 ESXI 启动项添加 OpenWrt。 ","date":"2021-10-14","objectID":"/posts/openwrt/:1:0","tags":["OpenWrt"],"title":"OpenWrt 初识记录","uri":"/posts/openwrt/"},{"categories":["All In One Server"],"content":"配置 文档配置会更快更方便，大部分都在 etc/config。 ","date":"2021-10-14","objectID":"/posts/openwrt/:2:0","tags":["OpenWrt"],"title":"OpenWrt 初识记录","uri":"/posts/openwrt/"},{"categories":["All In One Server"],"content":"network 设置网口和固定 IP network 路径： vi /etc/config/network 设置 LAN 口固定 IP 后可以使用 ifdown lanName 和 ifup lanName 重启接口。 ","date":"2021-10-14","objectID":"/posts/openwrt/:2:1","tags":["OpenWrt"],"title":"OpenWrt 初识记录","uri":"/posts/openwrt/"},{"categories":["All In One Server"],"content":"DHCP dhcp 文件路径： vi /etc/config/dhcp 配置格式： config hostoption name 'HostName'option dns '1'option mac '12:d3:3a:43:bc:54'option ip '192.168.50.12'option leasetime 'infinite'注意 host name 不可以有空格，否则导致 dhcp server 无法启动。 提示 本地无线设备在重启软路由 dhcp 依然无变化，尝试重启 wifi 转发路由器，wifi 设备的 ip 因为保持与路由连接，没有更新。 ","date":"2021-10-14","objectID":"/posts/openwrt/:2:2","tags":["OpenWrt"],"title":"OpenWrt 初识记录","uri":"/posts/openwrt/"},{"categories":["All In One Server"],"content":"动态 DNS ddns 文件路径： vi /etc/config/ddns 创建 token config service 'DNSPod'option service_name 'dnspod.cn'option enabled '1'option lookup_host 'domain name'option domain 'domain name'option username 'ID'option password 'Token'不同服务商的 ddns 配置不一样，可以 luci UI 配置。 ","date":"2021-10-14","objectID":"/posts/openwrt/:2:3","tags":["OpenWrt"],"title":"OpenWrt 初识记录","uri":"/posts/openwrt/"},{"categories":["All In One Server"],"content":"ShadowSocksR Plus+ 服务器节点 订阅 URL 添加 更新所有订阅服务节点 应用节点 保存 为保证 ddns 好用，记得清理缓存。 ","date":"2021-10-14","objectID":"/posts/openwrt/:2:4","tags":["OpenWrt"],"title":"OpenWrt 初识记录","uri":"/posts/openwrt/"},{"categories":["All In One Server"],"content":"端口映射 配置在防火墙里： vi /etc/config/ddns 配置如下： config redirect option target 'DNAT' option src 'wan' option dest 'lan' option proto 'tcp udp' option src_dport '80' option dest_ip '192.168.50.1' option dest_port '80' option name 'Router'","date":"2021-10-14","objectID":"/posts/openwrt/:2:5","tags":["OpenWrt"],"title":"OpenWrt 初识记录","uri":"/posts/openwrt/"},{"categories":["All In One Server"],"content":"HTTPS luci UI 配置 opkg update \u0026\u0026 opkg install openssl-util luci-app-uhttpd 或者也是在 config 里面 vi /etc/config/uhttpd 添加 https 监听和证书地址，证书使用 nigix 的。 注意重启 uhttpd /etc/init.d/uhttpd restart ","date":"2021-10-14","objectID":"/posts/openwrt/:2:6","tags":["OpenWrt"],"title":"OpenWrt 初识记录","uri":"/posts/openwrt/"},{"categories":["Reading"],"content":"这本书早有耳闻，也早早就躺在了我的电子书架中，但是没有跟朋友的聊天我还真的想不起来去阅读。 时日至今，我入职新公司已经四个月，肩负的任务也就更多。随着进入新公司环境的改变，整个人的心态也在升级，积极寻求飞速的进步。似乎英语需要提高，公司业务也还不透彻，技术上时不时同事和领导总会透漏出一点高深莫测，而项目中未来可能用到的技术也需要调查学习，似乎又进入了之前那种走火入魔的“快”节奏当中。而且真正分给我的工作，在我纠结性格和不”真“懂的双重作用下，无法做出一点成果，让我很是挫败很是无力，甚至于感觉到了工作压力。 十一前的一次聊天，朋友说你现在该看的是《最重要的事，只有一件》。 ","date":"2021-10-11","objectID":"/posts/%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E4%BA%8B%E5%8F%AA%E6%9C%89%E4%B8%80%E4%BB%B6/:0:0","tags":["读书笔记"],"title":"最重要的事，只有一件","uri":"/posts/%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E4%BA%8B%E5%8F%AA%E6%9C%89%E4%B8%80%E4%BB%B6/"},{"categories":["Reading"],"content":"对我的影响 最重要的事只有一件，这种多米诺人生的观点我很认同，所以对前面的大多阐述观点的章节并没有过多的重视。但是最重要的事并不是整理当下的 todo list，按照顺序来做。最重要的一件事就是如何达到成功的那件事，需要指定一个长久的目标，再通过倒推法，落实到笔头上，找到那件通向成功的最重要的那件事。然后再通过倒推法，落实到笔头寻找最重要的事。 整个的实现流程与软件敏捷开发很是相似，最重要的事就是按期完成用户体检良好的健壮的应用程序。然后为了实现这个目标倒推一步步需要实现的每一件事，最终寻找到我们当下应该做的事 ","date":"2021-10-11","objectID":"/posts/%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E4%BA%8B%E5%8F%AA%E6%9C%89%E4%B8%80%E4%BB%B6/:1:0","tags":["读书笔记"],"title":"最重要的事，只有一件","uri":"/posts/%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E4%BA%8B%E5%8F%AA%E6%9C%89%E4%B8%80%E4%BB%B6/"},{"categories":["Reading"],"content":"为重要的事安排时间 在完成优先事务的时候根据情况有两种实现方式： 如果事务是一次性的，要为它安排几个小时或几点，专心完成。 如果是重复性的，每天腾出来，固定的时间，把它变成一个习惯（坚持 66 天）。 ","date":"2021-10-11","objectID":"/posts/%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E4%BA%8B%E5%8F%AA%E6%9C%89%E4%B8%80%E4%BB%B6/:2:0","tags":["读书笔记"],"title":"最重要的事，只有一件","uri":"/posts/%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E4%BA%8B%E5%8F%AA%E6%9C%89%E4%B8%80%E4%BB%B6/"},{"categories":["Reading"],"content":"释放自己的潜力 成功人士在遇到了限制，他们就会寻找新的思维模式和方法。他们会暂停下来，确认自己的选择，一旦他们选择了最好的路，就会坚持不懈的努力。 目标不应该设定为自己能够达到的天花板，而要击穿这一条线，不然就无法保持不停学习的劲头。 一年前我有了目标，要脱离对日外包，学习专业基础和英语，在一次机会下成功脱离了日企。目标实现很快，如今已经进入新公司四个月了，但是学习劲头已经削减到当时的一半。 ","date":"2021-10-11","objectID":"/posts/%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E4%BA%8B%E5%8F%AA%E6%9C%89%E4%B8%80%E4%BB%B6/:3:0","tags":["读书笔记"],"title":"最重要的事，只有一件","uri":"/posts/%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E4%BA%8B%E5%8F%AA%E6%9C%89%E4%B8%80%E4%BB%B6/"},{"categories":["Reading"],"content":"对策 再此之前，我的灵感都只记录在 Sorted 中，而因为有些内容确实不是很重要占满了我的待办事项的篇幅，反而增加了惰性。 结合作者的理念，选用 Worktile 来解决我的重要事情的安排。灵感记录，读书 mono 记录，倒推我的目标所需要完成的一件一件事，并已卡片的方式进行管理，彻底分离工作学习和日常生活，减少拖延的习惯。 ","date":"2021-10-11","objectID":"/posts/%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E4%BA%8B%E5%8F%AA%E6%9C%89%E4%B8%80%E4%BB%B6/:4:0","tags":["读书笔记"],"title":"最重要的事，只有一件","uri":"/posts/%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E4%BA%8B%E5%8F%AA%E6%9C%89%E4%B8%80%E4%BB%B6/"},{"categories":["All In One Server"],"content":"{\"method\":\"set_ip_info\",\"params\":{\"ssid\":\"\\\"\\\"\",\"pswd\":\"123123 ; passwd -d admin ; echo enable \u003e /sys/class/tty/tty/enable; telnetd\"}} ","date":"2021-09-13","objectID":"/posts/%E5%B0%8F%E7%B1%B3-ha/:0:0","tags":["HomeAssistant"],"title":"HomeAssistant 接入小米网关","uri":"/posts/%E5%B0%8F%E7%B1%B3-ha/"},{"categories":["All In One Server"],"content":"记录一些 ESXI 使用中遇到的问题。 ","date":"2021-09-05","objectID":"/posts/esxi/:0:0","tags":["ESXI"],"title":"ESXI 相关配置","uri":"/posts/esxi/"},{"categories":["All In One Server"],"content":"虚拟交换机 ","date":"2021-09-05","objectID":"/posts/esxi/:1:0","tags":["ESXI"],"title":"ESXI 相关配置","uri":"/posts/esxi/"},{"categories":["All In One Server"],"content":"usb 硬件直通 lspci -v 获取所有芯片对应供应商 ID 和设备 ID lspci -v | grep “Class 0c03” 这的0C03就是类ID0XC03 vi /etc/vmware/passthru.map 8086:7ae2 Mass storage controller SATA controller: Intel Corporation Device 7ae2 8086 7ae2 d3d0 false Intel Corporation 8 Series/C220 Series Chipset Family USB xHCI 8086 8C31 d3d0 false 其中8086是供应商ID 8C31是设备ID d3d0和false固定值 Mass storage controller SATA controller: ASMedia Technology Inc. Device 1064 [vmhba2] 1b21 1064 d3d0 false Class 0106: 1b21:1064 ","date":"2021-09-05","objectID":"/posts/esxi/:2:0","tags":["ESXI"],"title":"ESXI 相关配置","uri":"/posts/esxi/"},{"categories":["All In One Server"],"content":"SSL 上传改名后的 SSL 在根目录下搜索 rui.crt /vmfs/volumes/datastore1 路径下是上传的 SSL 备份 /etc/vmware/ssl 中的 SSL 证书，用上传的覆盖 /etc/init.d/hostd restart #重启hostd服务 /etc/init.d/vpxa restart #重启vpxa服务 /etc/init.d/vpxa start #启动vpxa服务 /etc/init.d/hostd start #启动hostd服务 ","date":"2021-09-05","objectID":"/posts/esxi/:3:0","tags":["ESXI"],"title":"ESXI 相关配置","uri":"/posts/esxi/"},{"categories":["All In One Server"],"content":"许可证 JH09A-2YL84-M7EC8-FL0K2-3N2J2 许可证可下载 登录自己用户注册产品获取免费许可证。 分配许可证。 ","date":"2021-09-05","objectID":"/posts/esxi/:4:0","tags":["ESXI"],"title":"ESXI 相关配置","uri":"/posts/esxi/"},{"categories":["Frontend"],"content":"TypeScript 基础 ","date":"2021-05-07","objectID":"/posts/typescript/:1:0","tags":["TypeScript"],"title":"TypeScript 补漏","uri":"/posts/typescript/"},{"categories":["Frontend"],"content":"函数签名和重载 Signature Overloading function contactPeople(method: \"email\", ...people: HasEmail[]): void; function contactPeople(method: \"phone\", ...people: HasPhoneNumber[]): void; function contactPeople(method: \"email\" | \"phone\", ...people: (HasEmail | HasPhoneNumber)[]): void { } ","date":"2021-05-07","objectID":"/posts/typescript/:1:1","tags":["TypeScript"],"title":"TypeScript 补漏","uri":"/posts/typescript/"},{"categories":["Frontend"],"content":"词法作用域 Lexical Scope TODO ","date":"2021-05-07","objectID":"/posts/typescript/:1:2","tags":["TypeScript"],"title":"TypeScript 补漏","uri":"/posts/typescript/"},{"categories":["Frontend"],"content":"Interfaces 和 type aliases TODO ","date":"2021-05-07","objectID":"/posts/typescript/:2:0","tags":["TypeScript"],"title":"TypeScript 补漏","uri":"/posts/typescript/"},{"categories":["Frontend"],"content":"泛型 Generics ","date":"2021-05-07","objectID":"/posts/typescript/:3:0","tags":["TypeScript"],"title":"TypeScript 补漏","uri":"/posts/typescript/"},{"categories":["Frontend"],"content":"泛型使用 interface WrappedValue\u003cT\u003e { value: T; } let val: WrappedValue\u003cstring[]\u003e = { value: [] }; val.value; 鼠标悬停在 val.value 的 value 上可以看到： (property) WrappedValue\u003cstring[]\u003e.value: string[] 在各种类库的描述文件中也经常能够看到泛型的应用： interface MapLike\u003cT\u003e { [index: string]: T; } interface SortedReadonlyArray\u003cT\u003e extends ReadonlyArray\u003cT\u003e { \" __sortedArrayBrand\": any; } interface SortedArray\u003cT\u003e extends Array\u003cT\u003e { \" __sortedArrayBrand\": any; } ","date":"2021-05-07","objectID":"/posts/typescript/:3:1","tags":["TypeScript"],"title":"TypeScript 补漏","uri":"/posts/typescript/"},{"categories":["Frontend"],"content":"泛型参数 上述方式在使用 WrappedValue 时必须添加泛型参数，如果不添加使用会报错： Generic type ‘WrappedValue’ requires 1 type argument(s). 这里可以看到 WrappedValue 需要一个实参，那么我们也可以为其设置参数默认值，就可以不提供类型参数也能使用 WrappedValue： interface WrappedValue\u003cT = any\u003e { value: T; } let val: WrappedValue = { value: [] }; val.value; 下面是一个常用的泛型做参数的情况： function resolveOrTimeout\u003cT\u003e(promise: Promise\u003cT\u003e, timeout: number): Promise\u003cT\u003e { // =\u003e 1 return new Promise\u003cT\u003e((resolve, reject) =\u003e { // =\u003e 2 // start the timeout, reject when it triggers const task = setTimeout(() =\u003e reject(\"time up!\"), timeout); // =\u003e 3 promise.then(val =\u003e { // cancel the timeout clearTimeout(task); // =\u003e 4 // resolve with the value // =\u003e 5 resolve(val); }); }); } 泛型 T 设定后，会传递一个类型为 Promise\u003cT\u003e 名为 promise 的参数。 这个方法返回一个类型为 Promise\u003cT\u003e 的新 Promise。 根据 timeout 时间设置定时，如果时间到了，执行 callback，也就是新创建的 Promise 将 rejected。 如果 timeout 设定的时间没终止，传入的参数 promise 提前 fulfilled，那么直接清除延时。 将 fulfilled 的值 resolve 到新创建的 Promise 中。 这是一个典型的 Http 请求超时的解决方案。 ","date":"2021-05-07","objectID":"/posts/typescript/:3:2","tags":["TypeScript"],"title":"TypeScript 补漏","uri":"/posts/typescript/"},{"categories":["Frontend"],"content":"约束和作用域 Constraints Scope 可以通过 extends 来约束泛型： function arrayToDict\u003cT extends { id: string }\u003e(array: T[]): { [k: string]: T } { const out: { [k: string]: T } = {}; array.forEach(val =\u003e { out[val.id] = val; }); return out; } 如果用以下代码将不带有 id 属性对象的数组作为 arrayToDict 的参数： const myDict = arrayToDict([ { foo: \"foo\" } ]); 就会出现以下错误： Type ‘{ foo: string; }’ is not assignable to type ‘{ id: string; }’. Object literal may only specify known properties, and ‘foo’ does not exist in type ‘{ id: string; }’. 这里限制了泛型 T 内必须有 string 类型的 id 属性，所以我们可以使用 val.id。如果将约束 extends { id: string } 删除，就会看到 val.id 出现下面的错误： Property ‘id’ does not exist on type ‘T’. 泛型类似参数，同样享有函数参数同样的作用域，也可以应用在闭包中： function firstTuple\u003cT\u003e(firstElement: T) { return function finishTuple\u003cU\u003e(b: U) { return [a, b] as [T, U]; }; } const myTuple = startTuple([\"first\"])(42); 鼠标悬停在 myTuple 上可以看到该元组的类型： const myTuple: [string[], number] ","date":"2021-05-07","objectID":"/posts/typescript/:3:3","tags":["TypeScript"],"title":"TypeScript 补漏","uri":"/posts/typescript/"},{"categories":["Frontend"],"content":"泛型的使用 泛型只有在 input 和 output 同时需要时才使用，下面是一个没有必要用泛型的例子： interface Shape { draw(); } interface Circle extends Shape { radius: number; } function drawShapes1\u003cS extends Shape\u003e(shapes: S[]) { shapes.forEach(s =\u003e s.draw()); } function drawShapes2(shapes: Shape[]) { // this is simpler. Above type param is not necessary shapes.forEach(s =\u003e s.draw()); } 方法 2 和方法 1 起到了同样的效果，但是输出不再需要泛型。 但是如果有这样一个需求，Shape 中不但有 draw 方法，还有是否已经绘制的 Flag，并且我要在绘制之后将 Shape 对象返回，就可以使用泛型： interface Shape { draw(); isDrawn: boolean; } interface Circle extends Shape { radius: number; } function drawShapes\u003cS extends Shape\u003e(shapes: S[]): S[] { return shapes.map(s =\u003e { s.draw; s.isDrawn = true; return s; }) } ","date":"2021-05-07","objectID":"/posts/typescript/:3:4","tags":["TypeScript"],"title":"TypeScript 补漏","uri":"/posts/typescript/"},{"categories":["Frontend"],"content":"顶层类型和底层类型 ","date":"2021-05-07","objectID":"/posts/typescript/:4:0","tags":["TypeScript"],"title":"TypeScript 补漏","uri":"/posts/typescript/"},{"categories":["Frontend"],"content":"Top Types any unknow 顶层类型可以接收任何类型的值。 unknow 在不确定类型时无法获取它的值。 let myUnknown: unknown = \"hello, unknown\"; if (typeof myUnknown === \"string\") { // in here, myUnknown is of type string myUnknown.split(\", \"); // } if (myUnknown instanceof Promise) { // in here, myUnknown is of type Promise\u003cany\u003e myUnknown.then(x =\u003e console.log(x)); } typeof 在判断 null、array、object 时都是 object，需要用 instanceof 来判断原型链。 ","date":"2021-05-07","objectID":"/posts/typescript/:4:1","tags":["TypeScript"],"title":"TypeScript 补漏","uri":"/posts/typescript/"},{"categories":["Frontend"],"content":"Type Guards TypeScript 的类型判断自上而下进行，无法反向推断类型，比如函数的参数，如果没有定义类型，即使在后面赋值 string，参数类型仍然是 any。 可以用以下方式确认复杂类型： function isHasEmail(x: any): x is HasEmail { return typeof x.name === \"string\" \u0026\u0026 typeof x.email === \"string\"; } if (isHasEmail(myUnknown)) { // In here, myUnknown is of type HasEmail console.log(myUnknown.name, myUnknown.email); } 同理利用泛型有了下面这种通用的类型守卫： function isDefined\u003cT\u003e(arg: T | undefined): arg is T { return typeof arg !== \"undefined\"; } ","date":"2021-05-07","objectID":"/posts/typescript/:4:2","tags":["TypeScript"],"title":"TypeScript 补漏","uri":"/posts/typescript/"},{"categories":["Frontend"],"content":"Branded Types TODO ","date":"2021-05-07","objectID":"/posts/typescript/:4:3","tags":["TypeScript"],"title":"TypeScript 补漏","uri":"/posts/typescript/"},{"categories":["Frontend"],"content":"Bottom Types never 个人感觉没啥用。 ","date":"2021-05-07","objectID":"/posts/typescript/:4:4","tags":["TypeScript"],"title":"TypeScript 补漏","uri":"/posts/typescript/"},{"categories":["Frontend"],"content":"高级类型 ","date":"2021-05-07","objectID":"/posts/typescript/:5:0","tags":["TypeScript"],"title":"TypeScript 补漏","uri":"/posts/typescript/"},{"categories":["Frontend"],"content":"keyof 和 typeof typeof 是 JavaScript 就有的特性。 keyof 可以直接获取接口的属性名。 接口也可以用属性表达式来获取对应属性的类型。 interface CommunicationMethods { email: HasEmail; phone: HasPhoneNumber; fax: { fax: number }; } function contact\u003cK extends keyof CommunicationMethods\u003e( method: K, contact: CommunicationMethods[K] // 💡turning key into value -- a *mapped type* ) { //... } type AllType = keyof CommunicationMethods; let x: AllType = 'email'; type Email = CommunicationMethods['email']; ","date":"2021-05-07","objectID":"/posts/typescript/:5:1","tags":["TypeScript"],"title":"TypeScript 补漏","uri":"/posts/typescript/"},{"categories":["Frontend"],"content":"Built-In 类型 Partial /** * Make all properties in T optional */ type Partial\u003cT\u003e = { [P in keyof T]?: T[P]; }; 返回新的类型，并且所有的参数都是可选项。 Pick type HasThen\u003cT\u003e = Pick\u003cPromise\u003cT\u003e, \"then\" | \"catch\"\u003e; let hasThen: HasThen\u003cnumber\u003e = Promise.resolve(4); hasThen.then; 返回一个类型，指定允许访问的属性。 Extract Exclude Record ","date":"2021-05-07","objectID":"/posts/typescript/:5:2","tags":["TypeScript"],"title":"TypeScript 补漏","uri":"/posts/typescript/"},{"categories":["Frontend"],"content":"跟随 Acme Product Management 工程来理解 RxJS 在 Angular 中的响应式编程。 ","date":"2021-04-08","objectID":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/:0:0","tags":["Angular","RxJS"],"title":"Angular 中 RXJS 的应用","uri":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["Frontend"],"content":"初步接触 Reactive 在 Angular 的使用中，我们常常使用编程式模式（procedural pattern）实现从后端服务器获取数据，接下来让我们尝试声明式和响应式来实现这个功能。 ","date":"2021-04-08","objectID":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/:1:0","tags":["Angular","RxJS"],"title":"Angular 中 RXJS 的应用","uri":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["Frontend"],"content":"使用 Async Pipe component.ts： export class ProductListComponent implements OnInit, OnDestroy { pageTitle = 'Product List'; errorMessage = ''; products: Product[] = []; sub: Subscription; constructor(private productService: ProductService) { } ngOnInit(): void { this.sub = this.productService.getProducts() .subscribe( products =\u003e this.products = products, error =\u003e this.errorMessage = error ); } ngOnDestroy(): void { this.sub.unsubscribe(); } } component.html： \u003ctable class=\"table mb-0\" *ngIf=\"products\"\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eProduct\u003c/th\u003e \u003cth\u003eCode\u003c/th\u003e \u003cth\u003eCategory\u003c/th\u003e \u003cth\u003ePrice\u003c/th\u003e \u003cth\u003eIn Stock\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody *ngFor=\"let product of products\"\u003e \u003ctr\u003e \u003ctd\u003e{{ product.productName }}\u003c/td\u003e \u003ctd\u003e{{ product.productCode }}\u003c/td\u003e \u003ctd\u003e{{ product.categoryId }}\u003c/td\u003e \u003ctd\u003e{{ product.price | currency:\"USD\":\"symbol\":\"1.2-2\" }}\u003c/td\u003e \u003ctd\u003e{{ product.quantityInStock }}\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 在不使用 RxJS 的情况下，需要 subscribe 服务中获取的 Observable，在其 emit 数据时，将取得到的数据绑定到变量 products 上，模板跟随变量改变而渲染。 在使用 RxJS 时可以使用 angular 的 async pipe 直接将 Observable 绑定到模板中，变更检测识别到 emit 时，会自动渲染画面。 component.ts： export class ProductListComponent implements OnInit, OnDestroy { pageTitle = 'Product List'; errorMessage = ''; products$: Observable\u003cProduct[]\u003e constructor(private productService: ProductService) { } ngOnInit(): void { this.products$ = this.productService.getProducts(); } } component.html： \u003ctable class=\"table mb-0\" *ngIf=\"products$ | async as products\"\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eProduct\u003c/th\u003e \u003cth\u003eCode\u003c/th\u003e \u003cth\u003eCategory\u003c/th\u003e \u003cth\u003ePrice\u003c/th\u003e \u003cth\u003eIn Stock\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody *ngFor=\"let product of products\"\u003e \u003ctr\u003e \u003ctd\u003e{{ product.productName }}\u003c/td\u003e \u003ctd\u003e{{ product.productCode }}\u003c/td\u003e \u003ctd\u003e{{ product.categoryId }}\u003c/td\u003e \u003ctd\u003e{{ product.price | currency:\"USD\":\"symbol\":\"1.2-2\" }}\u003c/td\u003e \u003ctd\u003e{{ product.quantityInStock }}\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 使用 async pipe 的优点有如下几点： Observable 会在组件初始化时被 subscribe。 返回每次被 emit 的值。 当一个新的项目被 emit 时，无论任何变更检测策略，Angular 都会感知到变更并作出响应的画面渲染。 当组件销毁时自动 unsubscribe。 这就是为什么上个实例中使用 async pipe 后不在需要 OnDestroy Hook 的原因，我们不再需要手动 unsubscribe。 在未使用 async pipe 时，subscribe 的 callback 中的异常处理直接通过 Observer 的 error 回调来处理，直接在捕获到异常时将异常 message 赋值到一个 errorMessage 变量中，以插值的方式显示在模板中，那使用 RxJS 的异常处理该如何实现呢？ ","date":"2021-04-08","objectID":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/:1:1","tags":["Angular","RxJS"],"title":"Angular 中 RXJS 的应用","uri":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["Frontend"],"content":"异常处理 在 Observable 发生任何异常时，catchError 可以捕获到异常，使用这个操作符我们可以： 捕获异常后重新抛出一个异常。 也可以在异常发生时替换掉异常的 Observable 使操作继续进行。 替换异常 service.ts： public getProducts(): Observable\u003cProduct[]\u003e { return this.http.get\u003cProduct[]\u003e(this.productsUrl) .pipe( catchError(err =\u003e { console.log(err); return of([{ id: 1, productName: 'cart' }, { id: 2, productName: 'hammer' }]); }) ); } 如上在获取 product 数据时，如果发生异常可以捕获后返回一组新的数据的 Observable，使get 请求异常时仍然能够获取到一组假数据。 of 和 from 都能够创建 Observable of 创建的 Observable 会 emit 每一个实参 from 的期待实参是一个数组，它创建的 Observable 会 emit 数组中每一个元素 of(...apples) 等价于 from(apples) 重新抛出异常 service.ts： public getProducts(): Observable\u003cProduct[]\u003e { return this.http.get\u003cProduct[]\u003e(this.productsUrl) .pipe( catchError(err =\u003e { console.log(err); return throwError(err); }) ); } throwError 实际上也是个创建 Observable 函数，它创建的 Observable 没有任何项目，只 emit 一个异常通知，所以它也是变相的替换异常。 使用 async pipe 后如何赋值 errorMessage component.ts this.products$ = this.productService.getProducts() .pipe( catchError(err =\u003e { this.errorMessage = err; return EMPTY; }) ); 在初始化时，将 service 的 products$ 赋值给组件的 products$ 时可以添加 catchError 操作符，这时当捕获异常时，将 service 处理后的异常信息赋值给 errorMessage变量并显示在画面中。 这里返回了 EMPTY，它是空的 Observable，是 RxJS 中的常量。 import { EMPTY } from 'rxjs'; ","date":"2021-04-08","objectID":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/:1:2","tags":["Angular","RxJS"],"title":"Angular 中 RXJS 的应用","uri":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["Frontend"],"content":"OnPush 变更检查策略 @Component({ templateUrl: './product-list.component.html', styleUrls: ['./product-list.component.css'], changeDetection: ChangeDetectionStrategy.OnPush }) 参照变更检测 当改变为 OnPush 变更检查策略时，通过绑定变量的模板就无法跟随变量变更而进行渲染画面。 这时需要为 errorMessage 也创建一个 Observable。这在后面做 reacting to Action 时再进行修改。 ","date":"2021-04-08","objectID":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/:1:3","tags":["Angular","RxJS"],"title":"Angular 中 RXJS 的应用","uri":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["Frontend"],"content":"代码重构 这里代码是程序式编程实现的，如果使用声明式编程会有怎样的效果呢？ service.ts： public products$: Observable\u003cProduct[]\u003e = this.http.get\u003cProduct[]\u003e(this.productsUrl) .pipe( catchError(this.handleError) ); component.ts export class ProductListComponent { pageTitle = 'Product List'; errorMessage = ''; products$ = this.productService.products$ .pipe( catchError(err =\u003e { this.errorMessage = err; return EMPTY; }) ); constructor(private productService: ProductService) { } onAdd(): void { console.log('Not yet implemented'); } onSelected(categoryId: string): void { console.log('Not yet implemented'); } } 我们在 service 中声明 products$ Observable，它是用来获取 products 的数据，并为其添加了异常处理管道。然后，在组件中我们声明可以供模板使用的 products$ 并将其引用指向 service 声明的 products$，同时也再次为组件中的 products$ 添加异常处理管道获取异常信息以供模板显示。 可以看到，我们不但省略了之前的 OnDestroy Hook，现在连 OnInit Hook 也可以省略了，代码也变得清晰。 ","date":"2021-04-08","objectID":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/:1:4","tags":["Angular","RxJS"],"title":"Angular 中 RXJS 的应用","uri":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["Frontend"],"content":"构造数据 很多时候，从后端服务器获得的数据并不完全是我们想要的，比如下面的我们如果想在获取的数据中，让 Price 上浮 50%。这时候就用到了 map 操作符。 ","date":"2021-04-08","objectID":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/:2:0","tags":["Angular","RxJS"],"title":"Angular 中 RXJS 的应用","uri":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["Frontend"],"content":"Mapping an Http Response RxJS 的 map 就像 JavaScript 的 Array.prototype.map 方法一样： [1,2,3].map(num =\u003e num * 2) // [2,4,6] 首先我们要了解一个 Http Response Observable 会返回什么数据。 this.http.get\u003cProduct[]\u003e(this.productsUrl) 通过 Http get 请求会返回一个 Response，也就是说这个 Http Response Observable 只会 emit 一个 item——Response。那么我们直接使用 map 将无法得到 Product： 可以看到 item 是 Product[] 类型，所以 IDE 报错。也就是说我们需要再将 Product 数组通过 Array.prototype.map 方法进行 price 上浮 50%： public products$: Observable\u003cProduct[]\u003e = this.http.get\u003cProduct[]\u003e(this.productsUrl) .pipe( map(products =\u003e products.map( product =\u003e product.price * 1.5 )) catchError(this.handleError) ); 回顾一下 map 方法，它的返回值是回调函数返回值组成的数组，这里的 callback 返回值是 product.price * 1.5，也就是说现在 products$ 的类型是 Observable\u003cnumber[]\u003e，果然 IDE 也再次报错，那这回我们如何修改呢？ ","date":"2021-04-08","objectID":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/:2:1","tags":["Angular","RxJS"],"title":"Angular 中 RXJS 的应用","uri":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["Frontend"],"content":"改造数组元素 我们需要的是 Array.prototype.map 的 callback 返回 Product，而不是 number，那我们需要将其返回值构造成 Product 类型： public products$: Observable\u003cProduct[]\u003e = this.http.get\u003cProduct[]\u003e(this.productsUrl) .pipe( map(products =\u003e products.map( product =\u003e ({ ...product, price: product.price * 1.5, searchKey: [product.productName], }) as Product )), catchError(this.handleError) ); 这里使用了对象字面量的展开操作符 ...，将 product 展开到对象字面量中，并重写 price 属性。 ","date":"2021-04-08","objectID":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/:2:2","tags":["Angular","RxJS"],"title":"Angular 中 RXJS 的应用","uri":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["Frontend"],"content":"组合 Streams 有时我们需要多个数据集合，并组合它们的 Observable 数据流为同一个数据流。 如下面这个场景的 Category： 我们的 Products 数据流中有 Category 的 Id，但是在画面显示中，我们想要获 Id 所对应的字符串，这时候就需要将 Products 数据流和 Categories 的数据流组合到一起。 Combining Function： combineLatest forkJoin Combining Operator： withLatestFrom ","date":"2021-04-08","objectID":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/:3:0","tags":["Angular","RxJS"],"title":"Angular 中 RXJS 的应用","uri":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["Frontend"],"content":"将 Id 映射为 String 这里使用 Http get Request 获取 Categorise 数据： public productCategories$ = this.http.get\u003cProductCategory[]\u003e(this.productCategoriesUrl); 可以看出用上面三种组合方式都会得到同样的结果： 使用 combineLatest 方法组合两个 Observable： public productsWithCategory$ = combineLatest([ this.products$, this.productCategoryService.productCategories$ ]).pipe( map(([products, categories]) =\u003e products.map( product =\u003e ({ ...product, price: product.price * 1.5, category: categories.find(c =\u003e product.categoryId === c.id).name, searchKey: [product.productName], }) as Product )) ) 这里 map(([products, categories]) =\u003e {}) 使用了解构的新特性，直接用数组 [products, categories] 映射了接收到的结果。 ","date":"2021-04-08","objectID":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/:3:1","tags":["Angular","RxJS"],"title":"Angular 中 RXJS 的应用","uri":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["Frontend"],"content":"活动响应 应用程序会有很多用户活动响应，比如用户点击按钮，选择标签等。在这个 APM 实例中，如果想要在列表中进行过滤，那就需要我们的列表数据流响应用户的下拉列表框的选择行为，接下来学习 RxJS 的活动响应。 ","date":"2021-04-08","objectID":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/:4:0","tags":["Angular","RxJS"],"title":"Angular 中 RXJS 的应用","uri":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["Frontend"],"content":"过滤响应 ⁃ #### 为 products 添加 filter\r 根据前面的 RxJS 的 map 操作符嵌套 Array.prototype.map，这次使用 Array.prototype.filter 来做 products 的数据过滤代码如下： component.ts: productsSimpleFilter$ = this.productService.productsWithCategory$ .pipe( map(products =\u003e products.filter(product =\u003e this.selectedCategoryId ? product.categoryId === this.selectedCategoryId : true )) ) private selectedCategoryId: number = 1; 定义 selectedCategoryId 变量用来获取画面用户 action 值，并通过 filter 过滤结果，这里使用三元运算符来防止 selectedCategoryId 为空，当其为 null 或 undefined 时不添加过滤。 在模板中绑定 productsSimpleFilter$ 后，果然画面上能够过滤掉 categoryId 不等于 1 的数据。 绑定 Categories 数据 根据上面所学绑定 Category select 标签的 option。 component.ts： categories$ = this.productCategoryService.productCategories$ .pipe( catchError(err =\u003e { this.errorMessage = err; return EMPTY; }) ); ... onSelected(categoryId: string): void { this.selectedCategoryId = +categoryId; } component.html： \u003cselect class=\"form-control\" (change)=\"onSelected($event.target.value)\"\u003e \u003coption value=\"0\"\u003e- Display All -\u003c/option\u003e \u003coption *ngFor=\"let category of categories$ | async\" [value]=\"category.id\"\u003e{{ category.name }}\u003c/option\u003e \u003c/select\u003e 为 select 添加 onSelected 事件方法，这里使用 + 号将字符串隐式转换为数字。 但是画面刷新后发现 select 选择不同的 category 时并不能使列表数据变更，那我们该如何通知我们的 stream 来响应用户的活动呢？ Data Stream 和 Action Stream 以 Http 请求获取数据时，我们得到一个 Response，它只有一个 Item，这时这个 Observable 基本上说已经结束了它的使命，有了数据后我们不再需要它，这种 Stream 我们称为 Data Stream。 在用户使用过程中，一个活动可能频繁触发，我们需要一直订阅这种 Observable，响应每次用户的活动，这种 Stream 我们称为 Action Stream。 combineLatest 的特点是： 会等到所有的 Observable 都 emit 一次数据之后才开始 emit 数据。 在收集完一次数据之后，任何一个 Observable emit 数据，都会 emit 数据，并不会再次等待所有 Observable 再次 emit 数据。 弹珠图如下： 这样就能同时封装 Data Stream 和 Action Stream。 创建 Action Stream 有以下三种方式： 使用内置 stream，例如 form 表单的 value changes。 fromEvent Subject/BehaviorSubject 第三种是最常用的方式。 Subject 和 BehaviorSubject Subject 是的特殊 Observable，也是一个 Observer ，它可以多播。 BehaviorSubject 是特殊的 Subject，它在构造时必须有初始值。 接下来我们用 combineLatest 组合 Data Stream 和 Subject 创建的 Action Stream。 component.ts private categorySelectedSubject = new Subject\u003cnumber\u003e(); categorySelectedAction$ = this.categorySelectedSubject.asObservable(); products$ = combineLatest([ this.productService.productsWithCategory$, this.categorySelectedAction$ ]) .pipe( map(([products, selectedCategoryId]) =\u003e products.filter(product =\u003e selectedCategoryId ? product.categoryId === selectedCategoryId : true )), catchError(err =\u003e { this.errorMessage = err; return EMPTY; }) ); onSelected(categoryId: string): void { this.categorySelectedSubject.next(+categoryId); } 绑定 Data Stream 和 Action Stream 的三部： 创建可播的 Observable。 组合 Data Stream 和 Action Stream。 触发 Action 的 next 方法。 刷新画面已经可以看到在 select 标签选择不同的 category 时，列表中的数据已经能够过滤，但是画面初始化时没有数据。 回顾下 combineLatest 的弹珠图，必须每个 Observable 都 emit 时，组合后 Stream 才会 emit 项目，而我们没有选择 option 时，Action Stream 并没有 emit 任何项目，所以我们不会接收到数据。接下来学习如何设置初始值。 设置初始值 startWith 操作符，可以直接为 Action Stream 添加 startWith 操作的管道： this.categorySelectedAction$.pipe(startWith(0)) 果然这回画面初始化时就能显示所有的 products 了。 BehaviorSubject 是有初始值的 Subject，这里同样也可以使用 BehaviorSubject 来实现： private categorySelectedSubject = new BehaviorSubject\u003cnumber\u003e(0); categorySelectedAction$ = this.categorySelectedSubject.asObservable(); 刷新画面，同样也成功修复此功能。 ","date":"2021-04-08","objectID":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/:4:1","tags":["Angular","RxJS"],"title":"Angular 中 RXJS 的应用","uri":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["Frontend"],"content":"响应异常 前面将变更检测策略改为了 OnPush，导致我们绑定的变量已经不能被检测器所检测，那么就需要将变量编程一个 Observable。 我们的 errorMessage 不会像 Data Stream 一样只使用一次，而是一个会频繁发生的 Action Stream，所以这里选择使用 Subject 来实现。 component.ts private errorMessageSubject = new Subject(); public errorMessageAction$ = this.errorMessageSubject.asObservable(); public products$ = this.productService.productsWithCategory$ .pipe( catchError(err =\u003e { this.errorMessageSubject.next(err); return EMPTY; }) ); component.html \u003cdiv class=\"alert alert-danger\" *ngIf=\"errorMessageAction$ | async as errorMessage\"\u003e {{errorMessage}} \u003c/div\u003e ","date":"2021-04-08","objectID":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/:4:2","tags":["Angular","RxJS"],"title":"Angular 中 RXJS 的应用","uri":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["Frontend"],"content":"添加响应 应用 merge 组合函数和 scan 操作符。 merge 将 products 的 Data Stream 和添加操作的 Action Stream 连成一串，emit 的第一个项目是取回的全部数据，emit 的第二个项目是添加的新 product 数据。通过 scan 操作符将第二个项目添加到第一个项目中并输出。 service.ts public productsWithAdd$ = merge(this.productsWithCategory$, this.productInsertedAction$) .pipe( scan((products: Product[], insertedProduct: Product) =\u003e [...products, insertedProduct]) ) 这里使用了数组的展开操作符 ... 将 products 拷贝到新的数组中。 ","date":"2021-04-08","objectID":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/:4:3","tags":["Angular","RxJS"],"title":"Angular 中 RXJS 的应用","uri":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["Frontend"],"content":"最后 代码 RxJS模拟实现 ","date":"2021-04-08","objectID":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/:5:0","tags":["Angular","RxJS"],"title":"Angular 中 RXJS 的应用","uri":"/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["Frontend"],"content":"组件 @Component({ selector: 'events-app', template: ` \u003ch2\u003eHello world\u003c/h2\u003e \u003cimg src=\"/assets/images/basic-shield.png\"/\u003e ` }) 资源路径相对于 index.html，不能使用静态路径访问文件。 webpack 需要在编译 app 时知道哪一个文件要被捆绑，在 angular.json 中设置： \"options\": { \"outputPath\": \"dist/ng-fundamentals\", \"index\": \"src/index.html\", \"main\": \"src/main.ts\", \"polyfills\": \"src/polyfills.ts\", \"tsConfig\": \"tsconfig.app.json\", \"aot\": true, \"assets\": [ \"src/favicon.ico\", \"src/assets\" ], 组件需要在模块上注册 angular 才知道去哪里获取组件资源。 组件有一个 class 包含所有组件逻辑和内容。 ","date":"2021-04-05","objectID":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/:1:0","tags":["Angular"],"title":"ng-fundamentals 基础内容查缺补漏","uri":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/"},{"categories":["Frontend"],"content":"Angular 模板语法 ","date":"2021-04-05","objectID":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/:2:0","tags":["Angular"],"title":"ng-fundamentals 基础内容查缺补漏","uri":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/"},{"categories":["Frontend"],"content":"模板变量 #标识符 模板变量可以在模板的任何位置访问： \u003cevent-thumbnail #thumbnnail [event]=\"events\" (eventClick)=\"handleEventClicked($event)\"\u003e\u003c/event-thumbnail\u003e \u003cbutton class=\"btn btn-primary\" (click)=\"thumbnnail.logFoo()\"\u003eLog me some foo\u003c/button\u003e 可以在 HTML 中通过组件的模板变量访问子组件中的成员变量和成员方法。 ","date":"2021-04-05","objectID":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/:2:1","tags":["Angular"],"title":"ng-fundamentals 基础内容查缺补漏","uri":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/"},{"categories":["Frontend"],"content":"结构指令 * 星号代表结构指令 结构指令改变 DOM 的形状，它不是隐藏 DOM 而是添加或删除 DOM。 safe navigation operator ? ?. 以这种操作符绑定数据，预防 undefined *ngIf 在画面屡次显示隐藏 DOM 时会消耗过大，这时候应该使用 hidden 属性，画面初始化后不变选用 *ngIf。 ","date":"2021-04-05","objectID":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/:2:2","tags":["Angular"],"title":"ng-fundamentals 基础内容查缺补漏","uri":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/"},{"categories":["Frontend"],"content":"ng 绑定 class class binding \u003cspan [class.green]=\"event?.time === '8:00 am'\"\u003e{{event?.time}}\u003c/span\u003e ngClass \u003cspan [ngClass]=\"{green: event?.time === '8:00 am', bold: event?.time === '8:00 am'}\"\u003e{{event?.time}}\u003c/span\u003e ngClass 参数可以是函数，函数返回一个对象 {classKey：boolean,…} 或空格分隔字符串 ‘green bold’ 或者 class 数组 [‘green’ , ‘bold’]。 ","date":"2021-04-05","objectID":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/:2:3","tags":["Angular"],"title":"ng-fundamentals 基础内容查缺补漏","uri":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/"},{"categories":["Frontend"],"content":"ng 绑定 style style binding \u003cspan [style.color]=\"event?.time === '8:00 am' ? '#003300' : '#bbb'\"\u003e{{event?.time}}\u003c/span\u003e ngStyle [ngStyle] 后面接对象 {三元运算，三元运算}，也可以使用函数返回样式对象。 ","date":"2021-04-05","objectID":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/:2:4","tags":["Angular"],"title":"ng-fundamentals 基础内容查缺补漏","uri":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/"},{"categories":["Frontend"],"content":"模板表达式约束 以下内容不允许使用： Assignment（=,+=,==,etc） new Keyword Expression Chaining With ; Global Namespace 总结来说就是不允许产生副作用，不允许使用 global 命名空间内的成员。 ","date":"2021-04-05","objectID":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/:2:5","tags":["Angular"],"title":"ng-fundamentals 基础内容查缺补漏","uri":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/"},{"categories":["Frontend"],"content":"服务 ","date":"2021-04-05","objectID":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/:3:0","tags":["Angular"],"title":"ng-fundamentals 基础内容查缺补漏","uri":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/"},{"categories":["Frontend"],"content":"服务 @Injectable() constructor(private eventService: EventService) { } 这里的实际上是个简写，全文： @Injectable() private eventService: EventService; constructor(private _eventService: EventService) { this.eventService = _eventService; } 不要在组件构造函数中添加过多逻辑，应该将逻辑放到生命周期方法中。 implements OnInit 是 typeScript，只是语法上严谨，并不是必须的。 ","date":"2021-04-05","objectID":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/:3:1","tags":["Angular"],"title":"ng-fundamentals 基础内容查缺补漏","uri":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/"},{"categories":["Frontend"],"content":"引入第三方库 引入 toastr 时，在上面声明了一个 toastr ： declare let toastr: any; 实际上，在 angular.json 中已经添加了 toastr 的 Js 包，使其在 window 对象中添加了 toaster 变量，我们已经知道了 toastr object 是什么，我们可以直接使用这个对象中的接口，但是 typeScript 编译器不知道，所以只需要声明一个变量，让编译器通过编译即可。 在使用时，不要在使用的组件中直接声明 toastr 对象去使用，这样不容易 mock，不方便单元测试，取而代之的时提供一个可复用的服务。 目前，已经有了 ngx-toastr 库提供了 ToastrServie 接口供 angular 使用。 ","date":"2021-04-05","objectID":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/:3:2","tags":["Angular"],"title":"ng-fundamentals 基础内容查缺补漏","uri":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/"},{"categories":["Frontend"],"content":"记录状态 service 还有个功能是记录状态。例如身份认证。 ","date":"2021-04-05","objectID":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/:3:3","tags":["Angular"],"title":"ng-fundamentals 基础内容查缺补漏","uri":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/"},{"categories":["Frontend"],"content":"路由 组件都有 selector 属性，是因为其会被用在 html 的内部，当组件被作为路由使用时，则不需要 selector 属性。 import { Routes } from \"@angular/router\"; 路由只是一个数组配置（它是有序的，从上往下查找匹配路由）,这里导入 Routes 也同样只是为了 typeScript 的静态类型 check。 真正让这个数组奏效的是在模块中通过路由模块的根路由对该数组的载入： RouterModule.forRoot(appRoutes)\r{ path: '', redirectTo: 'events', pathMatch: 'full' } 注意添加默认路由。 pathMatch：path-matching 策略，默认 prefix，还有一个选项是 full prefix 以指定的 path 开始的 URL full 完全符合指定 path 的 URL ","date":"2021-04-05","objectID":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/:4:0","tags":["Angular"],"title":"ng-fundamentals 基础内容查缺补漏","uri":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/"},{"categories":["Frontend"],"content":"路由的步骤 添加一个 router-outlet 定义路由（一个常量数组）包含一个默认路由 在 module 中使用 RouterModule 载入路由 \u003cbase href=\"/\"\u003e ","date":"2021-04-05","objectID":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/:4:1","tags":["Angular"],"title":"ng-fundamentals 基础内容查缺补漏","uri":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/"},{"categories":["Frontend"],"content":"路由参数 定义参数 冒号提示 Angular 这是一个 URL 参数。 获取参数 import { ActivatedRoute } from \"@angular/router\"; 注入 ActivateRoute service 获取参数。 +this.route.snapshot.params['id'] 这里获取到的参数是字符串，需要转成 number ","date":"2021-04-05","objectID":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/:4:2","tags":["Angular"],"title":"ng-fundamentals 基础内容查缺补漏","uri":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/"},{"categories":["Frontend"],"content":"HTML 链接路由 [routerLink]=\"['/events', event.id]\" [routerLink] 的参数是数组，第一个元素是字符串路由地址，第二个元素是参数。 ","date":"2021-04-05","objectID":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/:4:3","tags":["Angular"],"title":"ng-fundamentals 基础内容查缺补漏","uri":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/"},{"categories":["Frontend"],"content":"Code 导航页面 Router.navigate(['/events', event.id]) 参数同上 ","date":"2021-04-05","objectID":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/:4:4","tags":["Angular"],"title":"ng-fundamentals 基础内容查缺补漏","uri":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/"},{"categories":["Frontend"],"content":"Route Guards 守卫即可以使用方法，也可以使用服务。 它既可以组织进入某个页面，也可以阻止离开某个页面。 canActivate 通过服务实现 canActivate { path: 'events/:id', component: EventDetailsComponent, canActivate: [EventRouteActivator] }, @Injectable() export class EventRouteActivator implements CanActivate { constructor(private eventService: EventService, private router: Router) { } canActivate(route: ActivatedRouteSnapshot) { const eventExists = !!this.eventService.getEvent(+route.params['id']); if (!eventExists) this.router.navigate(['/404']); return eventExists; } } canActivate 最后返回 boolean 值。 canDeactivate 通过方法实现 canDeactivate { path: 'events/new', component: CreateEventComponent, canDeactivate: ['canDeactivateCreateEvent'] }, 方法需要注入 providers，且不能使用缩写: providers: [ { provide: 'canDeactivateCreateEvent', useValue: checkDirytState } ] useValue 是方法，方法可以放在任何文件里： export function checkDirytState(component: CreateEventComponent) { if (component.isDirty) { return window.confirm('You have not saved this event, do you really want to cancel?') } return true; } ","date":"2021-04-05","objectID":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/:4:5","tags":["Angular"],"title":"ng-fundamentals 基础内容查缺补漏","uri":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/"},{"categories":["Frontend"],"content":"active link \u003ca [routerLink]=\"['/events']\" routerLinkActive=\"active\" [routerLinkActiveOptions]=\"{exact:true}\"\u003eAll Events\u003c/a\u003e routerLinkActive=“active” 添加在含有 routerlink 的标签上，当路由与标签指定的路由匹配，则添加 active class。 默认匹配路由字符串策略是 start with。 添加 [routerLinkActiveOptions]=\"{exact:true}\" 是完全符合。 ","date":"2021-04-05","objectID":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/:4:6","tags":["Angular"],"title":"ng-fundamentals 基础内容查缺补漏","uri":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/"},{"categories":["Frontend"],"content":"feature module 或 lazy loadable module 与 appModule 的区别： 不导入 BrowserModule 导入的 RouterModule 调用 forChild 方法 ","date":"2021-04-05","objectID":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/:4:7","tags":["Angular"],"title":"ng-fundamentals 基础内容查缺补漏","uri":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/"},{"categories":["Frontend"],"content":"表单 分为两种： Template-based Model-based 也称 reactive forms 表单如果都通过事件绑定的方式太复杂，所以引入 ngModel。 [(ngModel)] 双向绑定使用双括号 banana box 使用时根据需要决定如何绑定。 ","date":"2021-04-05","objectID":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/:5:0","tags":["Angular"],"title":"ng-fundamentals 基础内容查缺补漏","uri":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/"},{"categories":["Frontend"],"content":"Template-based Form 需要引入 FormsModule 注册到 module 中。 \u003cform #loginForm=\"ngForm\" (ngSubmit)=\"login(loginForm.value)\" autocomplete=\"off\"\u003e \u003cinput (ngModel)=\"userName\" name=\"userName\" id=\"userName\" type=\"text\" class=\"form-control\" placeholder=\"User Name...\" /\u003e \u003c/form\u003e 通过模板变量声明 Form，#loginForm=\"ngForm\" 指定该 Form 为 Angular 表单。 使用 ngSubmit 提交，参数是模板变量的值 loginForm.value。 用 name 声明 Form 中的成员属性。 表单验证 \u003cem *ngIf=\"newEventForm.controls.date?.invalid \u0026\u0026 (newEventForm.controls.date?.touched)\"\u003eRequired\u003c/em\u003e 基于模板的表单验证特别长，因为 formControl 不是 public 类型，它是 Form 的属性，所以在表单验证时特别繁琐。 ","date":"2021-04-05","objectID":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/:5:1","tags":["Angular"],"title":"ng-fundamentals 基础内容查缺补漏","uri":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/"},{"categories":["Frontend"],"content":"Model-based Form 还需要引入 ReactiveFormsModule 注册到 module 中。 步骤如下： 创建每个 FormControl 创建一个 FormGroup 为 FormGroup 配置 FormControl 给 HTML 中的 form 绑定 FormGroup 给 HTML 中的 field 绑定 FormControlName formControlName 绑定时不需要带任何括号，只是指定属性名 表单验证 表单验证是 FormControl 的第二个参数： let firstName = new FormControl(this.auth.currentUser.firstName, Validators.required); 如果有多个验证使用数组。 ","date":"2021-04-05","objectID":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/:5:2","tags":["Angular"],"title":"ng-fundamentals 基础内容查缺补漏","uri":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/"},{"categories":["Frontend"],"content":"自定义表单验证 validator 是什么 validator 就是一个函数： 返回 null 时 valid 返回 error 对象时 invalid error 对象 { key: value } 自定义表单验证方法 export function restrictedWords(...words) { return (control: FormControl): { [key: string]: any } =\u003e { if (!words) { return null; } let invalidWords = words.map(w =\u003e control.value.includes(w) ? w : null) .filter(w =\u003e w !== null); return invalidWords \u0026\u0026 invalidWords.length \u003e 0 ? { 'restrictedWords': invalidWords.join(', ') } : null; } } 这里为了使用 FormControl 使用了闭包。 注意 key 值 restrictedWords 与方法名一致。 ","date":"2021-04-05","objectID":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/:5:3","tags":["Angular"],"title":"ng-fundamentals 基础内容查缺补漏","uri":"/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/"},{"categories":["Frontend"],"content":"我们都知道创建一个服务，并通过 @Injectable 装饰器或者在 Module 中的 providers 中注册，并在组件的构造方法中通过如下方式依赖注入： import { AuthService } from '../user/auth.service'; export class NavBarComponent { constructor(public auth:AuthService){ } } 首先，必须先从其文件中导入 AuthService，并在构造函数中以参数的形式将其注入，参数的类型与文件内导出的 Class 一致，这个 Class 是 ES6 的语法糖，它实际上就是一个构造函数。 但是我们在这里是想得到一个 AuthService 的实例，我们并是想要得到 AuthService Class 或者 AuthService 函数，这就是 Angular 所做的：创建了一个实例并给我们这个实例。当我们注册了 AuthService Class，Angular 会创建这个 Class 的实例，并在任何引用它的构造函数中给我们这个实例，而创建这个实例就发生在我们将 AuthService 注册在 Module 的 providers 中。 那 Angular 是如何知道我们想要的是 AuthService 而不是其他 service 呢？ ","date":"2021-03-25","objectID":"/posts/angular-%E4%B8%AD%E7%9A%84-di/:0:0","tags":["Angular"],"title":"Angular 中的 DI","uri":"/posts/angular-%E4%B8%AD%E7%9A%84-di/"},{"categories":["Frontend"],"content":"Angular 如何知道我们要的是哪个 service 的实例呢？ Angular 通过截获组件构造函数中的声明，通过 TypeScript 的类型声明（这里就是 AuthService），在服务中寻找。所以实际上，它是通过 Class 作为一个 key 来寻找正确的对象，在上面的例子中，AuthService 实例就是在 AuthService 的 DI 注册时被创建的。 ","date":"2021-03-25","objectID":"/posts/angular-%E4%B8%AD%E7%9A%84-di/:1:0","tags":["Angular"],"title":"Angular 中的 DI","uri":"/posts/angular-%E4%B8%AD%E7%9A%84-di/"},{"categories":["Frontend"],"content":"Angular 与 Angular Js 的 DI 的区别 angular.module('app').service('auth',AuthService) 在 Angular Js 中，服务是通过上面的方式注册的，service() 方法有两个参数，第一个参数是一个字符串，第二个参数是我们想要的对象。所以 Angular Js 的依赖注入是通过字符串来匹配的。 当我们想要这个服务的实例时，我们需要创建一个同名的参数。而在我们编写代码时，常常因为单纯 miss 导致服务注入的失败，不得不在检查我们的代码。 而 Angular 中，我们使用 Class 或者 Type 作为我们的 key 或者换个词 token。 在 Angular 中，构造函数参数的类型 AuthService 起到两个作用：其一是用来给 TypeScript 识别变量类型，让我们在编写代码时 IDE 可以通过 . 来访问其中的成员。其二就是就是 Angular 通过这个 Type 声明在依赖注入注册中寻找匹配的对象。 所以在 Angular 中，我们创建一个 service 就直接创建一个 Class。 ","date":"2021-03-25","objectID":"/posts/angular-%E4%B8%AD%E7%9A%84-di/:1:1","tags":["Angular"],"title":"Angular 中的 DI","uri":"/posts/angular-%E4%B8%AD%E7%9A%84-di/"},{"categories":["Frontend"],"content":"如何使用 InjectionToken 我们通过使用一个消息通知库来学习如何使用 InjectionToken。 ","date":"2021-03-25","objectID":"/posts/angular-%E4%B8%AD%E7%9A%84-di/:2:0","tags":["Angular"],"title":"Angular 中的 DI","uri":"/posts/angular-%E4%B8%AD%E7%9A%84-di/"},{"categories":["Frontend"],"content":"如何在 Angular 中使用 toastr toastr 是一个通知 Jquery 库，目前已经有支持 Angular 版本的 ngx-toastr 提供使用，但是如果想使用原生的 toastr 我们该如何做呢。 根据官方的方法安装 toastr 库到我们的工程中，那如何在 Angular 中使用呢？ 首先在 Angular 的 webpack 文件中导入 toastr 的 style 和 script： \"styles\": [ \"node_modules/toastr/build/toastr.min.css\", \"src/styles.css\" ], \"scripts\": [ \"node_modules/jquery/dist/jquery.min.js\", \"node_modules/toastr/build/toastr.min.js\" ] 此时编译后的 SPA 中已经有了我们需要的 toastr 对象，我们可以在页面的控制台中查看 window.toastr 对象： 但是这时候在使用 toastr 对象时，IDE 会报错： 原因很简单，是因为 TypeScript 并不知道我们的 toastr 对象，这时候需要声明一下这个对象： declare let toastr: any; 这时候就可以顺利使用 toastr 库中的成员方法来弹出我们的消息提示框了。 ","date":"2021-03-25","objectID":"/posts/angular-%E4%B8%AD%E7%9A%84-di/:2:1","tags":["Angular"],"title":"Angular 中的 DI","uri":"/posts/angular-%E4%B8%AD%E7%9A%84-di/"},{"categories":["Frontend"],"content":"添加 toastr 服务 在一个工程中，我们肯定会不止一次的进行 HTTP 请求或者其他一些需要弹出消息提示框的情况，但每次都需要声明一个 toastr 对象有点太麻烦了，我们可以创建下面这个类注册为我们的服务： import { Injectable } from '@angular/core'; declare let toastr: any; @Injectable() export class ToastrService { success(message: string, title?: string) { toastr.success(message, title); } info(message: string, title?: string) { toastr.info(message, title); } warning(message: string, title?: string) { toastr.warning(message, title); } error(message: string, title?: string) { toastr.error(message, title); } } 这样我们也能过滤掉 toastr 中其他不必要的成员方法，方便项目中的同事使用。 ","date":"2021-03-25","objectID":"/posts/angular-%E4%B8%AD%E7%9A%84-di/:2:2","tags":["Angular"],"title":"Angular 中的 DI","uri":"/posts/angular-%E4%B8%AD%E7%9A%84-di/"},{"categories":["Frontend"],"content":"InjectionToken 注册服务 回顾一下上文中 Angular 的服务： 我们创建一个 service 就直接创建一个 Class 我们并没有创建一个可导出 toastr Class，并没有去用它作为 key 在我们的 Module 中注册它，我们不能在 Module 中导入 toastr，并将其添加到 providers 数组中。 因此我们如下修改我们的 toastr.service.ts： import { InjectionToken } from \"@angular/core\"; export let TOASTR_TOKEN = new InjectionToken\u003cToastr\u003e('toastr'); export interface Toastr { success(msg: string, title?: string): void; info(msg: string, title?: string): void; warning(msg: string, title?: string): void; error(msg: string, title?: string): void; } 使用 InjectionToken 构造函数 new 一个 TOASTR_TOKEN 对象，并指定其接口构造。这样就创建了我们的 InjectionToken。 然后在我们的 Module 中注册 toastr 服务： import { IToastr, TOASTR_TOKEN } from './common/toastr.service'; declare let toastr: IToastr; @NgModule({ ... providers: [ { provide: TOASTR_TOKEN, useValue: toastr } ] ... }) 首先导入我们的 IToastr 接口和 TOASTR_TOKEN InjectionToken，声明 toastr 对象，在 providers 数组中注册，这里注册时没有像之前的 AuthService 服务，只使用了类型。AuthService 的注册其实只是 { provide: AuthService , useClass: AuthService } 的简写（关于 useClass 和 userValue 后面再详细对比）。provide 的值就是 token，而 useValue 的值就是 Angular 为我们创建的实例。 ","date":"2021-03-25","objectID":"/posts/angular-%E4%B8%AD%E7%9A%84-di/:2:3","tags":["Angular"],"title":"Angular 中的 DI","uri":"/posts/angular-%E4%B8%AD%E7%9A%84-di/"},{"categories":["Frontend"],"content":"注入 InjectionToken 服务 接下来我们看看 InjectionToken 注册的服务如何使用。 import { Component, OnInit, Inject } from '@angular/core'; import { IToastr, TOASTR_TOKEN } from '../common/toastr.service'; constructor( private auth: AuthService, private router: Router, @Inject(TOASTR_TOKEN) private toastr: IToastr) { } 除了导入我们的接口 IToastr 和 TOASTR_TOKEN Token 之外，还需要从 @angular/core 中导入 Inject。 /** * Type of the Inject metadata. * * @publicApi */ export declare interface Inject { /** * A [DI token](guide/glossary#di-token) that maps to the dependency to be injected. */ token: any; } 我们可以看到 Inject 的参数是 token，当我们注入参数 toastr 时，IToastr 并不是我们依赖注入的 Token，而只是用来智能感知。真正指定了 Token 的是装饰器 @Inject()。 这样我就可以在我们的类中拿到 toastr 实例，像普通的 service 一样使用它： saveProfile(profileFormValue) { if (this.profileForm.valid) { this.auth.updateUser(profileFormValue.firstName, profileFormValue.lastName); this.toastr.success('Profile Saved'); this.router.navigate(['/events']); } } ","date":"2021-03-25","objectID":"/posts/angular-%E4%B8%AD%E7%9A%84-di/:2:4","tags":["Angular"],"title":"Angular 中的 DI","uri":"/posts/angular-%E4%B8%AD%E7%9A%84-di/"},{"categories":["Frontend"],"content":"四种 Provider 上面我们已经见过两种 provider，useValue 和 useClass。 在 Angular 的 DI 中一共有四种 provider： ValueProvider ClassProvider ExistingProvider FactoryProvider 它们分别使用四种方式为 Token 提供一个实例。 ","date":"2021-03-25","objectID":"/posts/angular-%E4%B8%AD%E7%9A%84-di/:3:0","tags":["Angular"],"title":"Angular 中的 DI","uri":"/posts/angular-%E4%B8%AD%E7%9A%84-di/"},{"categories":["Frontend"],"content":"总结 Angular 是在注册时产生的实例，这样产生的实例将在注册所在作用域内存在。 Angular 依赖注入时是通过 Token 来查找实例。 常用的服务注入实际上是使用 ClassProvider 提供的实例，而其 Token 就是它的 Class，在依赖注入时，Angular 截获其 Class 并以它为 Token 寻找实例。 相信我们都明了依赖注入的设计模式，也明确它的优势。可是在我们之前从 AngularJs 开始到 Angular 板砖的路程中没有过仔细学习 Angular 依赖注入的本质。这让我们在开发中只会复制粘贴代码，导致报错时让我们无从下手时，只能通过查阅文档的案例，来对比自己的代码中具体有哪些错误。但是当知道原理后，我们不但能清晰的写出依赖注入的代码，还可以灵活选用不同的 Provider，写出更漂亮的代码。 ","date":"2021-03-25","objectID":"/posts/angular-%E4%B8%AD%E7%9A%84-di/:4:0","tags":["Angular"],"title":"Angular 中的 DI","uri":"/posts/angular-%E4%B8%AD%E7%9A%84-di/"},{"categories":["Frontend"],"content":"原文：Angular Change Detection - How Does It Really Work? 与 AngularJs 中的等效方法相比，Angular 变更检测机制更加透明且易于推理。但是，在某些情况下（例如进行性能优化时），我们的确需要了解底层做了什么。因此，让我们通过研究以下主题来更深入地研究变更检测： 变更检测是如何实现的？ Angular 变更检测器是什么样的，我能看到它吗？ 默认变更检测机制如何工作 打开 / 关闭变更检测，并手动触发 避免变更检测循环：生产与开发模式 OnPush 变更检测模式到底做了什么？ 使用 Immutable.js 简化 Angular 应用程序的构建 总结 如果你在寻找更多关于 OnPush 变更检测的信息，看一下这篇文章 Angular OnPush Change Detection and Component Design - Avoid Common Pitfalls。 ","date":"2021-03-23","objectID":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/:0:0","tags":["Angular"],"title":"Angular 变更检测——它到底是如何工作的？","uri":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"},{"categories":["Frontend"],"content":"变更检测是如何实现的 Angular 可以检测组件数据何时变更，然后自动重新渲染视图以反映该变更。但是，如何在诸如单击按钮之类的低级事件发生之后做到这一点，这可以在页面任何地方发生吗？ 要了解它是如何工作的，我们首先需要意识到在 JavaScript 中整个运行时可以被设计重写。如果需要，我们可以重写 String 或 Number 中的函数。 ","date":"2021-03-23","objectID":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/:1:0","tags":["Angular"],"title":"Angular 变更检测——它到底是如何工作的？","uri":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"},{"categories":["Frontend"],"content":"重写浏览器默认机制 Angular 在启动时会修补几个低级浏览器 API，例如 addEventListener，这是用于注册所有浏览器事件（包括单击处理程序）的浏览器功能。Angular 会用下面等效的新版本替换 addEventListener： // this is the new version of addEventListener function addEventListener(eventName, callback) { // call the real addEventListener callRealAddEventListener(eventName, function() { // first call the original callback callback(...); // and then run Angular-specific functionality var changed = angular.runChangeDetection(); if (changed) { angular.reRenderUIPart(); } }); } 新版本的 addEventListener 为任何事件处理程序增加了更多功能：其不仅调用已注册的回调，而且 Angular 还可以运行变更检测并更新 UI。 ","date":"2021-03-23","objectID":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/:1:1","tags":["Angular"],"title":"Angular 变更检测——它到底是如何工作的？","uri":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"},{"categories":["Frontend"],"content":"低级运行时补丁是如何工作的？ 浏览器 API 的低级补丁是由 Angular 的 Zone.js 库完成的。了解什么是 zone 很重要。 zone 无非是一个执行上下文，它可以在多个 JavaScript VM 1执行回合后幸存下来。这是一种通用机制，我们可以用来向浏览器添加额外的功能。Angular 用 Zone 来触发变更检测，但另一种可能的用途是进行应用程序性能分析，或跟踪跨多个 VM 轮次运行的长堆栈跟踪。 ","date":"2021-03-23","objectID":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/:1:2","tags":["Angular"],"title":"Angular 变更检测——它到底是如何工作的？","uri":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"},{"categories":["Frontend"],"content":"支持浏览器异步 API 修补以下常用的浏览器机制，以支持变更检测： 全部浏览器事件（click、mouseover、keyup 等） setTimeout() 和 setInterval() Ajax HTTP 请求 实际上，Zone.js 修补了许多其他浏览器 API，以明了地触发 Angular 变更检测，例如 Websockets。看看Zone.js 测试说明来了解当前支持的功能。 这种机制的局限性之一在于，如果由于某些原因 Zone.js 不支持异步浏览器 API，那么将不会触发变更检测。例如，IndexedDB 回调就是这种情况。 这就解释了变更检测是如何触发的，但是一旦触发，它实际上如何工作？ ","date":"2021-03-23","objectID":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/:1:3","tags":["Angular"],"title":"Angular 变更检测——它到底是如何工作的？","uri":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"},{"categories":["Frontend"],"content":"变更检测树 每个 Angular 组件都有一个关联的创建于应用程序启动时的变更检测器。例如下面 TodoItem 组件： @Component({ selector: 'todo-item', template: `\u003cspan class=\"todo noselect\" (click)=\"onToggle()\"\u003e{{todo.owner.firstname}} - {{todo.description}} - completed: {{todo.completed}}\u003c/span\u003e` }) export class TodoItem { @Input() todo:Todo; @Output() toggle = new EventEmitter\u003cObject\u003e(); onToggle() { this.toggle.emit(this.todo); } } 如果切换 Todo 状态，则此组件将接收 Todo 对象作为输入并发生事件。为了使示例更有趣，Todo 类包含嵌套对象： export class Todo { constructor(public id: number, public description: string, public completed: boolean, public owner: Owner) { } } 我们可以看到 Todo 有一个属性 owner，它本身是一个具有两个属性的对象：firstname 和 lastname。 ","date":"2021-03-23","objectID":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/:1:4","tags":["Angular"],"title":"Angular 变更检测——它到底是如何工作的？","uri":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"},{"categories":["Frontend"],"content":"Todo Item 变更检测器是什么样子的？ 我们实际上可以在运行时看到变更检测器的外观！ 可以通过访问某个属性查看它，只需在 Todo 类中添加一些代码以[触发断点](https://github.com/jhades/blog.angular-university.io/blob/master/ng2-change-detection/src/todo .ts＃L11)。 执行到断点时，我们可以遍历堆栈跟踪并查看实际的变更检测： 不用担心，你将永远不必调试此代码！也不涉及任何魔术，它只是在应用程序启动时构建的普通 JavaScript 方法。但是它是做什么的呢？ ","date":"2021-03-23","objectID":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/:1:5","tags":["Angular"],"title":"Angular 变更检测——它到底是如何工作的？","uri":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"},{"categories":["Frontend"],"content":"默认变更检测机制如何工作？ 乍一看，此方法可能看起来很奇怪，并且其全部变量命名奇怪。但是，通过更深入地研究它，我们发现它的操作非常简单：对于模板中使用的每个表达式，它会将表达式中使用的属性的当前值与该属性的先前值进行比较。 如果前后的属性值不同，它将把 isChanged 设置为 true，就是这样！差不多了，它是通过使用名为 looseNotIdentical() 的方法进行值比较，使用 === 比较但指定 NaN 相等逻辑（请参阅 [here](https://github.com/angular/angular/blob/50548fb5655bca742d1056ea91217a3b8460db08/modules/ angular2 / src / facade / lang.ts＃L367)）。 ","date":"2021-03-23","objectID":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/:2:0","tags":["Angular"],"title":"Angular 变更检测——它到底是如何工作的？","uri":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"},{"categories":["Frontend"],"content":"嵌套对象的 owner 如何处理？ 我们可以在变更检测器代码中看到 owner 嵌套对象的属性同样被检测差异。但是只比较 firstname 属性，不比较 lastname 属性。 这是因为组件模板中未使用 lastname （请参阅 here）！ 同样，出于相同原因，未比较 Todo 的顶级 id 属性。这样，我们可以放心地说： 默认情况下，Angular 变更检测通过检测模板表达式的值是否已更改来工作。这是针对所有组件都做的处理。 我们还可以得出以下结论： 默认情况下，Angular 不会进行深度对象比较来检测变更，它仅考虑模板使用的属性。 ","date":"2021-03-23","objectID":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/:2:1","tags":["Angular"],"title":"Angular 变更检测——它到底是如何工作的？","uri":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"},{"categories":["Frontend"],"content":"为什么默认情况下变更检测如此工作？ Angular 的主要目标之一是更加透明和易于使用，从而使框架用户不必费劲地调试框架并了解内部机制，就能够有效地使用它。 如果你熟悉 AngularJs，想象一下 $digest() 和 $apply() 以及何时使用它们或不使用它们的所有陷阱。Angular 的主要目标之一就是避免这种情况。 ","date":"2021-03-23","objectID":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/:2:2","tags":["Angular"],"title":"Angular 变更检测——它到底是如何工作的？","uri":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"},{"categories":["Frontend"],"content":"引用如何比较? 事实上 Javascript 对象是可变的，Angular 希望为这些对象提供开箱即用的全面支持。 想象一下，如果 Angular 默认变更检测机制将基于组件输入的引用比较而不是默认机制，那将会是什么样子？ 即使是像 TODO 应用程序这样简单的东西，构建起来也很棘手：开发人员必须非常小心地创建新的 Todo，而不是简单地更新属性。 但是，正如我们将看到的，如果我们确实需要的话，仍然可以自定义 Angular 变更检测。 ","date":"2021-03-23","objectID":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/:2:3","tags":["Angular"],"title":"Angular 变更检测——它到底是如何工作的？","uri":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"},{"categories":["Frontend"],"content":"性能如何？ 请注意，todo list 组件的变更检测器如何显式引用 todos 属性。 做到这一点的另一种方法是在组件的属性之间动态循环，从而使代码通用而不是特定于组件。这样，我们就不必在启动时为每个组件构建一个变更检测器！ 那么这是怎样一回事呢？ ","date":"2021-03-23","objectID":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/:2:4","tags":["Angular"],"title":"Angular 变更检测——它到底是如何工作的？","uri":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"},{"categories":["Frontend"],"content":"快速浏览虚拟机内部 所有这些都与 Javascript 虚拟机的工作方式有关。尽管通常 VM 即时编译器无法轻易地将用于动态比较属性的代码优化为本机代码。 这与变更检测器的特定代码不同，变更检测器确实显式访问每个组件输入属性。该代码非常类似于我们手工编写的代码，并且很容易被虚拟机转换为本地代码。 使用生成的显式的检测器的最终结果是一种变化检测机制，该机制非常快（比 AngularJs 更快），可预测且易于推理。 但是，如果遇到性能困境，是否有一种方法可以优化变更检测？ ","date":"2021-03-23","objectID":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/:2:5","tags":["Angular"],"title":"Angular 变更检测——它到底是如何工作的？","uri":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"},{"categories":["Frontend"],"content":"OnPush 变更检测模式 如果我们的 Todo list 真的很大，我们可以配置 TodoList 组件仅在 Todo list 变更时才进行更新。这可以通过将组件变更检测策略改为 OnPush 来完成： @Component({ selector: 'todo-list', changeDetection: ChangeDetectionStrategy.OnPush, template: ... }) export class TodoList { ... } 现在让我们给应用程序添加一对按钮：一个按钮通过直接对列表的第一条进行改变来切换，另一个按钮将 Todo 添加到整个列表中。代码如下： @Component({ selector: 'app', template: `\u003cdiv\u003e \u003ctodo-list [todos]=\"todos\"\u003e\u003c/todo-list\u003e \u003c/div\u003e \u003cbutton (click)=\"toggleFirst()\"\u003eToggle First Item\u003c/button\u003e \u003cbutton (click)=\"addTodo()\"\u003eAdd Todo to List\u003c/button\u003e` }) export class App { todos:Array = initialData; constructor() { } toggleFirst() { this.todos[0].completed = ! this.todos[0].completed; } addTodo() { let newTodos = this.todos.slice(0); newTodos.push( new Todo(1, \"TODO 4\", false, new Owner(\"John\", \"Doe\"))); this.todos = newTodos; } } 现在让我们看看两个新按钮的行为： 第一个按钮“Toggle First Item”不起作用！ 这是因为 toggleFirst() 方法直接使列表的元素发生改变。 TodoList 无法检测到它，因为它的输入引用 todos 没有改变。 第二个按钮确实起作用！ 请注意，方法 addTodo() 创建了 todo list 的副本，然后向该副本添加了一个项目，最后用复制的 list 替换了 todos 成员变量。这会触发变更检测，因为该组件在其输入中检测到引用变更：它收到了一个新列表！ 在第二个按钮中，直接修改 todo list 将不起作用！我们需要一个新列表。 ","date":"2021-03-23","objectID":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/:3:0","tags":["Angular"],"title":"Angular 变更检测——它到底是如何工作的？","uri":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"},{"categories":["Frontend"],"content":"OnPush 真的只是通过引用比较比较输入吗? 事实并非如此，如果你尝试通过单击来切换 todo，它仍然可以使用！即使你将 TodoItem 也切换为 OnPush。这是因为 OnPush 不仅仅检查组件输入中的更改：如果组件发生事件，该事件也将触发变更检测。 根据引用自 Victor Savkin 的博客： 当使用 OnPush 检测器时，框架将在其任何输入属性发生更改时，当它触发事件或当 Observable 触发事件时检查 OnPush 组件。 尽管可以提供更好的性能，但如果与可变对象一起使用，则使用 OnPush 的代价是很高的复杂性。它可能会引入难以推理和重现的错误。但是有一种方法可以使 OnPush 的使用成为可行的。 ","date":"2021-03-23","objectID":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/:3:1","tags":["Angular"],"title":"Angular 变更检测——它到底是如何工作的？","uri":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"},{"categories":["Frontend"],"content":"使用 Immutable.js 简化 Angular 应用程序的构建 如果我们仅使用不可变对象和不可变列表构建应用程序，则可以在所有地方使用 OnPush，而不会陷入变更检测错误的风险。这是因为对于不可变对象，修改数据的唯一方法是创建一个新的不可变对象并替换先前的对象。对于不可变的对象，我们可以保证： 一个新的不可变对象将始终触发 OnPush 变更检测 我们不能忘记创建对象的新副本而意外地产生错误，因为修改数据的唯一方法是创建新对象 对于不可变的一个不错的选择是使用 Immutable.js 库。该库提供了用于构建应用程序的不可变基元，例如不可变对象（Map）和不可变列表。 该库也可以以类型安全的方式使用，阅读之前的文章，以获取有关如何执行此操作的示例。 ","date":"2021-03-23","objectID":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/:3:2","tags":["Angular"],"title":"Angular 变更检测——它到底是如何工作的？","uri":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"},{"categories":["Frontend"],"content":"避免变更检测循环：生产与开发模式 Angular 变更检测的重要属性之一是，它与 AngularJs 不同，它强制执行单向数据流：当更新控制器类上的数据时，变更检测将运行并更新视图。 但是视图的更新本身并不会触发进一步的更改，而这些更改又会触发视图的进一步更新，从而在 AngularJs 中创建了 digest cycle。 ","date":"2021-03-23","objectID":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/:4:0","tags":["Angular"],"title":"Angular 变更检测——它到底是如何工作的？","uri":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"},{"categories":["Frontend"],"content":"如何在Angular中触发变更检测循环？ 一种方法是使用生命周期回调。例如，在 TodoList 组件中，我们可以触发回调到另一个组件改变其中一个绑定： ngAfterViewChecked() { if (this.callback \u0026\u0026 this.clicked) { console.log(\"changing status ...\"); this.callback(Math.random()); } } 错误消息将显示在控制台中： EXCEPTION: Expression '{{message}} in App@3:20' has changed after it was checked\r仅当我们在开发模式下运行 Angular 时，才会引发此错误消息。如果启用生产模式会怎样？ @NgModule({ declarations: [App], imports: [BrowserModule], bootstrap: [App] }) export class AppModule {} 在生产模式下，不会引发该错误，并且不会发现问题。 ","date":"2021-03-23","objectID":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/:4:1","tags":["Angular"],"title":"Angular 变更检测——它到底是如何工作的？","uri":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"},{"categories":["Frontend"],"content":"变更检测问题经常发生吗？ 我们的确必须竭尽全力触发变更检测循环，但以防万一最好在开发阶段始终使用开发模式，因为这样可以避免问题。 这种保证是以 Angular 始终运行变更检测两次为代价的，这是第二次检测此类情况。在生产模式下，变更检测仅运行一次。 ","date":"2021-03-23","objectID":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/:4:2","tags":["Angular"],"title":"Angular 变更检测——它到底是如何工作的？","uri":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"},{"categories":["Frontend"],"content":"打开 / 关闭变更检测并手动触发 在某些特殊情况下，我们确实希望关闭变更检测。想象一下一种情况，其中大量数据通过 Websocket 从后端到达。我们可能只想每 5 秒更新一次 UI 的特定部分。为此，我们首先将变更检测器注入到组件中： constructor(private ref: ChangeDetectorRef) { ref.detach(); setInterval(() =\u003e { this.ref.detectChanges(); }, 5000); } 如我们所见，我们只是拆下了变更检测器，这有效地关闭了变更检测。然后，我们只需调用 detectChanges() 每 5 秒手动触发一次。 现在，让我们快速总结一下有关 Angular 变更检测所需的所有知识：它是什么，它如何工作以及变更检测主要的可用类型是什么。 ","date":"2021-03-23","objectID":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/:5:0","tags":["Angular"],"title":"Angular 变更检测——它到底是如何工作的？","uri":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"},{"categories":["Frontend"],"content":"总结 Angular 变更检测是内置的框架功能，可确保组件数据与其 HTML 模板视图之间的自动同步。 变更检测通过检测常见的浏览器事件（例如鼠标单击，HTTP 请求和其他类型的事件），并确定是否需要更新每个组件的视图来起作用。 变更检测有两种类型： 默认变更检测：Angular 通过比较事件发生之前和之后的所有模板表达式值（对于组件树的所有组件）来决定是否需要更新视图。 OnPush 变更检测：这是通过检测一些新数据是否已通过组件输入或使用异步管道订阅的 Observable 显式推送到组件中而起作用的。（还有触发事件） Angular的默认变更检测机制实际上与 AngularJs 相似：它比较浏览器事件前后的模板表达式的值，以查看是否有所更改。所有组件都这样做。但是也有一些重要的区别： 其一，没有变更检测循环，也没有像 AngularJs 中的 digest cycle。这允许仅通过查看其模板和其控制器就可以推断出每个组件。 另一个区别是，由于构建了变更检测器，因此组件中检测变更的机制要快得多。 最后，与 AngularJs 不同，变更检测机制是可以自定义的。 JavaScript VM，JavaScript 虚拟机，即 JavaScript 引擎。 ↩︎ ","date":"2021-03-23","objectID":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/:6:0","tags":["Angular"],"title":"Angular 变更检测——它到底是如何工作的？","uri":"/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"},{"categories":["Frontend"],"content":"This document helps clarify the different adjectives surrounding promises, by dividing them up into two categories: states and fates. 本文档阐明围绕 Promise 的各种形容词，把它们分为两部分：状态和命运。 ","date":"2021-02-10","objectID":"/posts/states-and-fates/:0:0","tags":["JavaScript"],"title":"JS Promise States and Fates","uri":"/posts/states-and-fates/"},{"categories":["Frontend"],"content":"States Promises have three possible mutually exclusive states: fulfilled, rejected, and pending. Promise 有三种可能的互斥独立状态：已兑现、已拒绝、待定。 A promise is fulfilled if promise.then(f) will call f “as soon as possible.” 如果 promise.then(f) 会马上调用 f，那么 promise 是已兑现状态。 A promise is rejected if promise.then(undefined, r) will call r “as soon as possible.” 如果 promise.then(undefined, r) 会马上调用 r，那么 promise 是已拒绝状态。 A promise is pending if it is neither fulfilled nor rejected. 如果它既不是已兑现也不是已拒绝，那么 promise 是待定状态。 We say that a promise is settled if it is not pending, i.e. if it is either fulfilled or rejected. Being settled is not a state, just a linguistic convenience. 如果 promise 不是待定状态，我们说它已敲定，无论它是已兑现还是已拒绝。已敲定不是一个状态，知识一个语言上的便利。 ","date":"2021-02-10","objectID":"/posts/states-and-fates/:1:0","tags":["JavaScript"],"title":"JS Promise States and Fates","uri":"/posts/states-and-fates/"},{"categories":["Frontend"],"content":"Fates Promises have two possible mutually exclusive fates: resolved, and unresolved. Promise 有两种可能的互斥独立命运：已决议，未决议。 A promise is resolved if trying to resolve or reject it has no effect, i.e. the promise has been “locked in” to either follow another promise, or has been fulfilled or rejected. 如果 promise 已决议，尝试决议或拒绝它是没有任何效果，promise 被接下来其他 promise 锁定，或者已被兑现或拒绝。 A promise is unresolved if it is not resolved, i.e. if trying to resolve or reject it will have an impact on the promise. 如果 promise 未决议，如果尝试兑现或拒绝会对 promise 产生影响。 ","date":"2021-02-10","objectID":"/posts/states-and-fates/:2:0","tags":["JavaScript"],"title":"JS Promise States and Fates","uri":"/posts/states-and-fates/"},{"categories":["Personal Insights Essays"],"content":"前天电脑维修完毕，测试完电脑装箱时，维修大哥要帮我找个胶带粘一下箱口。而我拒绝了，马上就要准备走，大哥直接给我按住了，他说：“你呀是我见过的客人里最急的，别急，粘一下安全。” 他的“别急安全”四个字点醒了我。以前的我跨过水坑之前都会因为觉得有一定的风险会摔倒而绕道，现在怎么突然变成了这样子。 ","date":"2021-02-05","objectID":"/posts/%E5%88%AB%E6%80%A5/:0:0","tags":["个人感悟"],"title":"别急","uri":"/posts/%E5%88%AB%E6%80%A5/"},{"categories":["Personal Insights Essays"],"content":"着急 自找到学习的方向到今天，正好一个半月时间。在这段学习 JavaScript 的时间中，可以说收获颇丰，成长可见。因应用了《刻意练习》中所提到的“监测进步”，让我找到了学习的乐趣，略微沉迷于学习 JavaScript。 但，一个半月前的计划中 JavaScript 并不是全部，而我也深知大家都说的“JavaScript 学好了什么都不愁”就是一句空话。H5 和 Css 其实都是前端吃饭的工具，也都是我的弱项，而朋友们还在继续学习 C++、算法编译原理等。国外的这些朋友学习能力真的让我惊叹，原版犀牛书加红宝书竟然一个月零七天就带着输出读完了，我禁不住叫她魔鬼好几次。 我知道我个人的技术职业生涯是肯定无法超越他们的，年龄也赶不上他们年轻，但是我还是想逼自己做到我能做到的最好，毕竟我的工作环境中也不都是他们这样的年轻人不是吗？😂😂😂 每时每刻我能做到我最尽力的准备去迎接随时可能出现的机遇就好了。 于是，上下班匆忙的我，午间热饭吃饭时候端着手机看的我，做饭时听书的我，泡脚时看视频的我，遛狗时想着下一步该如何规划的我，睡前想着今天完成的进度的我。这就是今天的我现在的我。我很庆幸目前我的学习劲头还没有被疲劳给打败，我竟然用我的全部生活在学一个东西。 ","date":"2021-02-05","objectID":"/posts/%E5%88%AB%E6%80%A5/:1:0","tags":["个人感悟"],"title":"别急","uri":"/posts/%E5%88%AB%E6%80%A5/"},{"categories":["Personal Insights Essays"],"content":"后怕 如果没有这位工程师大哥叫我别急，我可能现在还反应不过来我的状态。就如同一根紧绷的琴弦，早晚会断。 学习这件小事堆时间应该是最傻的办法了吧。而我更傻，我似乎在催眠自己，我利用了午休上下班的时间在做学习相关的事情，我遛狗的时候也有心系学业，我利用了更多的时间，减少了我的短时快乐而假装增加了学习的时间。 但这真的奏效吗？就像书上说的，真正重要的还是专注。在冥想的练习上都没有什么进步的我，在车上听书的效果基本上就是一个路边的广告就带飞了我的思绪，往往只能对几段话略有印象，剩下都靠自己拼凑。遛狗时候呢想的计划什么的并不会像在工作中，灵光一闪之后可以直接记录在 oneNote 上，往往也是想了一想忘在了脑后。到了真正学习的时间，我真正做到了专注的吸收知识了吗？ ","date":"2021-02-05","objectID":"/posts/%E5%88%AB%E6%80%A5/:2:0","tags":["个人感悟"],"title":"别急","uri":"/posts/%E5%88%AB%E6%80%A5/"},{"categories":["Personal Insights Essays"],"content":"专注 记得知乎上有一个帖子，说 35 岁的你想对 25 岁的你说些什么，有一条是如果有时间尽量多休息多闭闭眼。身体真的是革命的本钱，就现在我的眼睛又干又涩。 似乎专注真的是很多作家都喜欢的主题，不仅仅是学习的专注，《浓缩睡眠法》中就连睡觉都要专注。午休间好好消化消化食儿，出去晒晒太阳休息休息眼睛，做饭的时候用心研究每味调味品的效果，遛狗时候好好注意路况与老婆聊聊天，这曾经是我多么向往的生活啊。而对于我来说，做这些事情的时间我都有拥用，但是却没有专注的享受它们。这种不专注的生活方式同样也带入了我的学习，这是必然的。 也就是说我现在真的是在想尽办法去用最笨的方式去学习–堆时间。 ","date":"2021-02-05","objectID":"/posts/%E5%88%AB%E6%80%A5/:3:0","tags":["个人感悟"],"title":"别急","uri":"/posts/%E5%88%AB%E6%80%A5/"},{"categories":["Personal Insights Essays"],"content":"不怕 就像跑步一样，如果看着电视剧听着音乐，而不专注的感受跑步时身体的变化，可能就会更容易受伤，这个原因让我在跑步时会一直保持专注。 学习能力并非一朝一夕就能改变，而学习效果也是一个曲线，它是会伴随练习不断变得陡峭。过分的追求进度不能保证完全掌握知识，书读百遍其义自见，往往需要反复循环多遍，练习多次，在不断犯错中成长。所以我不能害怕我的落后，不能害怕我与他们的距离越来越远，不能害怕被后面的人追上来。 带着不怕的心理，专注的学习，不要让自己在学习上受伤。 感谢这位大哥，点醒我。从今天开始“慢”下来。用心专注面对生活中每一件事，给我一个健康的身心来迎接未来。用心专注面对学习，一步一个脚印的提升职业技能来迎接未来。 ","date":"2021-02-05","objectID":"/posts/%E5%88%AB%E6%80%A5/:4:0","tags":["个人感悟"],"title":"别急","uri":"/posts/%E5%88%AB%E6%80%A5/"},{"categories":["Frontend"],"content":"在数组章节提到数组的展开运算符时，作者举例说明展开运算符可以进行拷贝，原为如下： The spread operator is a convenient way to create a (shallow) copy of an array: let original = [1,2,3]; let copy = [...original]; copy[0] = 0; // Modifying the copy does not change the original original[0] // =\u003e 1 copy 对象为 original 展开后的数组字面量，但是拷贝后的数组修改了序列为 0 的元素的值，但是被拷贝数组中序列为 0 的元素的值并没有被改变，作者称这样的拷贝为浅拷贝， 在我的印象中深浅拷贝是如下形式的： 浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，在修改了拷贝元，拷贝先也会跟着改变。 深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，拷贝元和拷贝之间脱离了关系。 但是这个实例中，作者只测试了拷贝先的修改，我又做了如下测试： let original = [1,2,3]; let copy = [...original]; original[0] = 10; copy[0] // =\u003e 1 就是说在修改被拷贝数组时，拷贝后的数组也不跟随改变。 所以作者的浅拷贝指的是什么呢？ 问题需要最根溯源，从基础来解决问题，下面就先来回溯下数据类型。 ","date":"2021-02-04","objectID":"/posts/javascript-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/:0:0","tags":["JavaScript"],"title":"JavaScript 深浅拷贝","uri":"/posts/javascript-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"categories":["Frontend"],"content":"JavaScript 数据类型 最新 ECMAScript 标准定义了九种类型： 六个数据类型 typeof undefined === 'undefined'; typeof true === 'boolean'; typeof 123 === 'number'; typeof 'str' === 'string'; typeof 123n ==='bigint'; typeof Symbol('symbol') === 'symbol'; 两个结构类型 typeof {} === 'object'; typeof (() =\u003e {}) === 'function'; 结构根 typeof null === 'object'; 以上九种类型又分为原始值（Primitive Value）和对象（Object）： Primitive values Boolean type Null type Undefined type Number type BigInt type String type Symbol type Objects 原始值（又名基本类型）其值存放在栈中，它的值无法被修改，当对基本类型进行操作时，会在新的空间内创建一个原始值。 对象也就是引用类型（又名复杂类型），它只在栈中保存其内存地址，指向存在堆中的数据，当对其进行修改时，栈内的地址进行改变，指向堆中另外的数据。 ","date":"2021-02-04","objectID":"/posts/javascript-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/:1:0","tags":["JavaScript"],"title":"JavaScript 深浅拷贝","uri":"/posts/javascript-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"categories":["Frontend"],"content":"问题解决 现在再回想一下深浅拷贝的定义就会发现，其只是针对复杂类型。也就是说在原文中所用示例在用展开运算符对 original 数组进行拷贝，而其拷贝的值是初始数组内的元素，而其元素只是 number 类型的原始值，因此这个实例无法展示其浅拷贝特性。 了解了这些后，针对引用类型做一个实验： let original = [{a:1},2,3]; let copy = [...original]; original[0].a = 10; copy[0].a; // =\u003e 10 这个例子中初始数组中的第一个元素为对象，是一个引用类型数据，拷贝后对其中的 a 属性进行修改，果然拷贝后的数组中第一个元素的 a 属性值也被修改。如此证明了展开运算符的确是浅拷贝。 ","date":"2021-02-04","objectID":"/posts/javascript-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/:2:0","tags":["JavaScript"],"title":"JavaScript 深浅拷贝","uri":"/posts/javascript-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"categories":["Frontend"],"content":"总结 这次的错误理解的根源是对基本概念掌握的不够牢固，这里展开运算符只是将初始数组中的元素展开到一个新的数组字面量中，因此并不是拷贝整个数组，而是拷贝数组中的每个元素，所以深浅拷贝的描述对象也是数组中的元素。 ","date":"2021-02-04","objectID":"/posts/javascript-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/:3:0","tags":["JavaScript"],"title":"JavaScript 深浅拷贝","uri":"/posts/javascript-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"categories":["Frontend"],"content":"函数的 this 对于基础薄弱的前端程序员一直是一个比较头疼的问题，在对 ES6 的模糊和对 ES6 之前的函数作用域不理解双重打击下，往往无法区分 this 值到底是什么，因而在编写程序时常常需要通过测试当前作用域的 this 是什么，再去使用，甚至是某些公司严格规定哪种方式去实现。 细细的看完了权威指南的第七版受益颇多，但是作者并没有拿出一个章节专门将相关内容进行汇总，这里就通过函数的声明和调用来总结下函数 this 值的几种情况。 ## 函数定义 函数的定义有多种方式来适应不同的使用场景： 函数声明语句 函数表达式 箭头函数 嵌套函数 应用函数的构造函数 Function() ### 函数声明语句 与大多数声明语句一样，以关键字 + 名称的形式来进行声明，函数用关键字 function 来声明： function testOutPut(){ console.log('Hello world!'); } 函数声明语句是函数名变成一个变量，这个变量的值是函数本身。这里实际上是声明了一个 testOutPut 变量，并讲函数对象赋值给 testOutPut。在 JavaScript 的运行时中，函数对象创建于该函数所在作用域的代码开始执行之前，也就是说，在同一个上下文中，可以先执行函数调用再进行函数语句声明。只是第一个函数作为值的概念的应用场景。 ### 函数表达式 函数表达式是一个赋值语句，将一个函数赋值给一个变量或常量。感觉函数表达式跟函数声明语句的运行时一样，但是如果先进行函数调用再进行函数表达式来定义函数将会异常。因为函数表达式在没有执行前并没有将函数赋值给变量，所以它也就不能被引用。 beforeDefined(); let beforeDefined = function(){console.log(1);} // Uncaught ReferenceError: beforeDefined is not defined 函数表达式的函数名称是可选项，如果给函数表达式添加一个函数名，那这个函数的局部函数作用域内会包含该属性的函数名的对象，其值绑定的是该函数： const f = function fact(x) { if (x \u003c= 1) return 1; else return x*fact(x-1); }; 只有在函数局部作用域内会有这个对象，有点闭包的感觉。 ### 箭头函数 箭头函数是 ES6 的新特性，在实际生产中非常常用。它支持很多简洁语法： const sum = (x, y) =\u003e { return x + y; }; const sum = (x, y) =\u003e x + y; const polynomial = x =\u003e x*x + 2*x + 3; const constantFunc = () =\u003e 42; 注意参数和箭头之间不能换行，否则会引起歧义。 除此之外，它最大的特性就是它继承定义它环境的 this 值，我理解添加箭头函数的目的就是为了解决方法的嵌套函数 this 值为全局对象（严格模式下是 undefined）的缺陷： let o = { a:1, m:function(){ let self = this; console.log(this === o); f(); function f(){ console.log(this === o); console.log(self === o); console.log(this); } } } o.m(); // true // flase // true // Window{...} 在 ES6 之前，我们需要通过闭包将 this 值保存在变量中使用，而有了箭头函数，可以直接继承 m 方法的 this 值： o = { a:1, m:function(){ let self = this; console.log(this === o); const f = () =\u003e { console.log(this === o); console.log(self === o); console.log(this); } f(); } } o.m(); // true // true // true // {a: 1, m: ƒ} ### 嵌套函数 函数可以嵌套在其他函数内。嵌套函数可以访问包含它们函数的变量和参数（闭包）： function first(){ let strFirst = \"first\"; second(); function second(){ let strSecond = \"second\"; third(); function third(){ console.log(strFirst); console.log(strSecond); } } } first(); // first // second ### Function() 构造函数创建函数 Function() 函数的实参都是字符串，最后一个实参是函数体。 const f = new Function(\"x\", \"y\", \"return x*y;\"); 这里想到一个情况，当函数名相同时是否会报错： const f1 = new Function(\"x\", \"x\", \"return x;\"); f1(1,2); // 2 实际情况并没有，再次测试一下直接函数声明语句使用两个相同的参数，也没有报错： function f2(x,x,y){return x*y}; f2(1,2,2); // 4 这样看实际上跟函数外部用 var 声明的变量在函数中再次声明一个效果： var x = 1; function test(){let x = 2;console.log(x)}; console.log(x); test(); // 1 // 2 函数变量声明多个相相同的变量名时，传递的实参值将反复覆盖同名参数。 Function() 构造函数非常重要的一点，就是它所创建的函数并不是使用词法作用域，相反，函数体代码的编译类似顶层函数，看书上的一个例子： let scope = \"global\"; function constructFunction() { let scope = \"local\"; return new Function(\"return scope\"); // Doesn't capture local scope! } constructFunction()(); // \"global\" ## 函数调用 函数调用和方法调用很常见就不再赘述，这里有三种很少使用的调用方式： 构造函数调用 间接调用 隐式调用 ### 构造函数调用 function CreatObj(){ this['p'] = \"property\"; } o = new CreatObj(); // CreatObj {p: \"property\"} 构造函数创建一个新对象，并将这个对象作为它的上下文，也就是说构造函数中的 this 值是新创建的对象。 构造函数通常没有 return 语句，当显示的用 return 语句返回一个对象时，构造函数创建的对象将变成它 return 的对象，其他情况当没有返回值或返回一个原始值时，返回值都被忽略，返回它新创建的对象。 ","date":"2021-01-16","objectID":"/posts/%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%92%8C%E8%B0%83%E7%94%A8%E6%8E%8C%E6%8F%A1%E5%87%BD%E6%95%B0%E7%9A%84-this-%E5%80%BC/:0:0","tags":["JavaScript"],"title":"通过函数声明和调用掌握函数的 this 值","uri":"/posts/%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%92%8C%E8%B0%83%E7%94%A8%E6%8E%8C%E6%8F%A1%E5%87%BD%E6%95%B0%E7%9A%84-this-%E5%80%BC/"},{"categories":["Frontend"],"content":"间接调用 JavaScript 万物接对象，对象就有自己的属性和方法。同理，函数也是对象，也有自己的方法和属性，而 call() 和 apply() 方法也可以用来间接调用函数。 call() 方法 MDN 中对于 call() 的解释已经很明了了： The call() method calls a function with a given this value and arguments provided individually. f.call(o, 1, 2); 这里不过是将 o 对象作为函数 f 调用的上下文，并传入两个实参 1 和 2 作为实参列表，也就是说它等同与下面的代码： o.m = f; o.m(1, 2); delete o.m; 这里注意 delete 语句，目的就是说函数在使用 call 方法时只是临时将 o 作为 f 的上下文并调用。而函数还有个不涉及调用的方法 bind() 它可以返回一个新的函数对象，f.bind(o);，而这个对象将一直绑定 o 为函数 f 的 this 值。 apply() 方法 The apply() method calls a function with a given this value, and arguments provided as an array (or an array-like object). 不难看出 apply() 和 call() 基本一致，只是实参以数组或者类似数组的对象进行传递。这里对类似数组的对象进行测试： function test(...args){ console.log(this); for(item in args) console.log(item); } let o = {a:1}; let likeArr = {p1:1,p2:2}; likeArr.length = 2; let unLikeArr = {p1:1,p2:2}; test.apply(o,likeArr); // {a: 1} // 0 // 1 test.apply(o,unLikeArr); // {a: 1} 可见有了 length 的对象就被当作是类似数组的对象。 this 值 可见当 call() 和 apply() 调用函数时给函数绑定了一个上下文 this 值，但是箭头函数是个特例，它从它定义的位置的上下文继承 this 值。也就是说当给箭头函数定义的函数使用这两个方法时，第一个参数将被忽略： let o = { a: 1, f: function(){ const oBind = {b:1}; const test = ()=\u003e console.log(this); test.apply(oBind); } } o.f(); // {a: 1, f: ƒ} ","date":"2021-01-16","objectID":"/posts/%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%92%8C%E8%B0%83%E7%94%A8%E6%8E%8C%E6%8F%A1%E5%87%BD%E6%95%B0%E7%9A%84-this-%E5%80%BC/:0:1","tags":["JavaScript"],"title":"通过函数声明和调用掌握函数的 this 值","uri":"/posts/%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%92%8C%E8%B0%83%E7%94%A8%E6%8E%8C%E6%8F%A1%E5%87%BD%E6%95%B0%E7%9A%84-this-%E5%80%BC/"},{"categories":["Frontend"],"content":"隐式调用 getter 和 setter 方法在获取或者设置它的属性时可能被隐式调用。 在对象进行字符串或者数值型和 BigInt 类型转换时，会隐式调用 toString() 和 valueOf() 方法。 循环可迭代对象的元素时会产生很多方法调用。 模板字符串可以调用函数。 Proxy 对象的任何一个操作都会导致函数调用。 ## 关于函数 this 值的总结 函数 this 值有以下几种情况： 函数声明语句和函数表达式定义的函数，在非严格模式下 this 值永远是 global，严格模式下是 undefined。 apply() call() bind() 方法用在非箭头函数时，第一个参数作为函数运行时的 this 值。 箭头函数的 this 值永远继承于它所定义的位置的 this 值。 对象的方法中 this 值是该对象的引用，嵌套在该对象中的函数不为方法，所以遵循函数的 this 值（global 或者 undefined）。 构造函数的 this 值是新创建的对象。 闭包只是参数和变量作用域的引用，与 this 值无关。 ","date":"2021-01-16","objectID":"/posts/%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%92%8C%E8%B0%83%E7%94%A8%E6%8E%8C%E6%8F%A1%E5%87%BD%E6%95%B0%E7%9A%84-this-%E5%80%BC/:0:2","tags":["JavaScript"],"title":"通过函数声明和调用掌握函数的 this 值","uri":"/posts/%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%92%8C%E8%B0%83%E7%94%A8%E6%8E%8C%E6%8F%A1%E5%87%BD%E6%95%B0%E7%9A%84-this-%E5%80%BC/"},{"categories":["Frontend"],"content":"undefined 是一个变量，它有可能被篡改，所以使用void（0）来代替他，但是在做实验的时候发现虽然给它赋值不报错，取值时候 undefined 却并没有改变。 undefined = 0 // 0 undefined // undefined 这回学习到了变量作用域，再结合之前学的对象的属性，深入了解下 undefined 到底什么时候会被篡改。 ","date":"2020-12-24","objectID":"/posts/%E9%80%9A%E8%BF%87%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-undefined/:0:0","tags":["JavaScript"],"title":"通过变量作用域深入了解 undefined","uri":"/posts/%E9%80%9A%E8%BF%87%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-undefined/"},{"categories":["Frontend"],"content":"函数作用域和声明提前 别的语言一般为块级作用域，JavaScript 取而代之使用了函数作用域：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。 var a = function test(o){ var i = 0; // i在整个函数体内均是有定义的 if(typeof o == \"object\"){ var j = 4; // j在函数体内是有定义的，不仅仅是在这个代码段内 for(var k=0; k \u003c 3; k++){ // k在函数体内是有定义的，不仅仅是在循环内 console.log(k); // 输出数字0～2 } console.log(k); // k已经定义了，输出3 } console.log(k); // k已经定义了，输出3 console.log(j); // j已经定义了，输出4 }; JavaScript 的这个特性被非正式地称为声明提前（hoisting），即 JavaScript 函数里声明的所有变量（但不涉及赋值）都被“提前”至函数体的顶部。 var a = '1'; function f(){ console.log(a); var a = '2'; console.log(a); } 由于函数作用域的特性，变量 a 的声明被提前到了整个函数体最前面，声明了但是没赋值，所以第一次 console 是 undefined。执行到 var 语句时才被赋值，这应该也是为什么可以一个变量多次 var 声明的原因，后面每一次 var 只是起到了赋值的作用。 ","date":"2020-12-24","objectID":"/posts/%E9%80%9A%E8%BF%87%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-undefined/:1:0","tags":["JavaScript"],"title":"通过变量作用域深入了解 undefined","uri":"/posts/%E9%80%9A%E8%BF%87%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-undefined/"},{"categories":["Frontend"],"content":"ES6 块作用域 ES6 弥补了这这个概念，追加了 let 和 const，也就有了 {} 块作用域的概念，const 用来声明常量，这个就不提了，用上面的例子感受一下 let 和 var 的区别。 var a = function test(o){ var i = 0; // i在整个函数体内均是有定义的 if(typeof o == \"object\"){ let j = 4; // j在if块内是有定义的 for(var k=0; k \u003c 3; k++){ // k在函数体内是有定义的，不仅仅是在循环内 console.log(k); // 输出数字0～2 console.log(j); // j已经定义了，输出4 } console.log(k); // k已经定义了，输出3 } console.log(k); // k已经定义了，输出3 console.log(j); // j在块外，抛出异常Uncaught ReferenceError: j is not defined }; let 和 const 只有在块内是被声明的。 ","date":"2020-12-24","objectID":"/posts/%E9%80%9A%E8%BF%87%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-undefined/:2:0","tags":["JavaScript"],"title":"通过变量作用域深入了解 undefined","uri":"/posts/%E9%80%9A%E8%BF%87%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-undefined/"},{"categories":["Frontend"],"content":"全局变量的本质 当声明一个 JavaScript 全局变量时，实际上是定义了全局对象的一个属性。当使用 var 声明一个变量时，创建的这个属性是不可配置的，无法通过 delete 运算符删除。 test =1 // 1 window.test // 1 delete test // true window.test // undefined var test = 1 // undefined window.test // 1 delete test // false window.test // 1 可以看到当定义一个全局变量的时候他变成了 window 的属性。 JavaScript 可以允许使用 this 关键字来引用全局对象，但是不能引用局部变量中存放的对象。 this.test // 1 ","date":"2020-12-24","objectID":"/posts/%E9%80%9A%E8%BF%87%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-undefined/:3:0","tags":["JavaScript"],"title":"通过变量作用域深入了解 undefined","uri":"/posts/%E9%80%9A%E8%BF%87%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-undefined/"},{"categories":["Frontend"],"content":"深入理解 undefined 的本质 undefined 明明是个变量为什么赋值后无法使用呢。任何地方都可以直接使用 undefined，那他是一个全局变量一个全局的属性，事实也果然如此。 window.undefined == undefined // true 而属性分两类，他们的特征如下： 数据属性 value：就是属性的值。 writable：决定属性是否能被赋值。 enumerable：决定 for in 能否枚举该属性。 configurable：决定该属性能否被删除或者改变特征值。 访问器属性（getter/setter） getter：函数或 undefined，在取属性值时被调用。 setter：函数或 undefined，在设置属性值时被调用。 enumerable：决定 for in 能否枚举该属性。 configurable：决定该属性能否被删除或者改变特征值。 查看下全局属性 undefined 的属性特征。 console.log(Object.getOwnPropertyDescriptor(window,'undefined')); // configurable: false // enumerable: false // value: undefined // writable: false writable：false，就是这个原因 undefined 虽然是个全局变量，但是我们赋值之后他并没有被改变。那为什么还需要用 void(0) 来代替 undefined 呢？结合上面的函数作用域再做一个实验。 function test() { var undefined = 100; console.log(undefined); var obj = {a : undefined}; console.log(Object.getOwnPropertyDescriptor(obj,'a')); } test(); // 100 // configurable: true // enumerable: true // value: 100 // writable: true 在函数作用域中，undefined 被从声明并赋值为 100，无论是直接 console 它自己还是去查看 undefined 属性特性都能看出，undefined 变量被修改了。这也就说在函数作用域内 undefined 可以被修改。 function test() { const undefined = 100; console.log(undefined); const obj = {a : undefined}; console.log(Object.getOwnPropertyDescriptor(obj,'a')); test(); } // 100 // configurable: true // enumerable: true // value: 100 // writable: true 块作用域内也一样可以被修改，得出结论 undefined 是一个类似 var 声明一样可以被重复声明的全局属性，而他的属性特性 writable 是 false，所以不能被修改，但是在非全局作用域内，他是可以被篡改的，这时候就要注意用 void (0) 来替代 undefined。 ","date":"2020-12-24","objectID":"/posts/%E9%80%9A%E8%BF%87%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-undefined/:4:0","tags":["JavaScript"],"title":"通过变量作用域深入了解 undefined","uri":"/posts/%E9%80%9A%E8%BF%87%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-undefined/"},{"categories":["Frontend"],"content":"作用域链^1 以书中的角度用对象属性去看作用域链： JavaScript最顶层的代码，其作用域链只有一个全局对象。 不包含嵌套的函数，其作用域两个对象：函数自身的变量对象和全局对象。 活动对象(activation object)，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端 对于包含了嵌套函数的函数，其作用域包含至少三个对象：自身的变量对象，外层的变量对象（将自身嵌套的函数），全局变量对象。 作用域链给我的感觉类似原型链，将函数的上下文构成了链表的形式，而方法执行时一层一层往外找，所以为了方便链表从上到下查找属性，所以有了声明提前，链表最顶端为嵌套函数的最里层，链表最底端则是全局变量对象。 function test(){ var fun1,fun2; for(var i=0;i\u003c2;i++){ if(i === 0){ fun1 = function(){console.log('fun1:i='+i)}; } if(i === 1){ fun2 = function(){console.log('fun2:i='+i)}; } }; fun1(); fun2(); }∫ test(); // fun1:i=2 // fun2:i=2 ","date":"2020-12-24","objectID":"/posts/%E9%80%9A%E8%BF%87%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-undefined/:5:0","tags":["JavaScript"],"title":"通过变量作用域深入了解 undefined","uri":"/posts/%E9%80%9A%E8%BF%87%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-undefined/"},{"categories":["Frontend"],"content":"注 在看 JavaScript 权威指南第七版第八章时发现作者将原来的作用域链的“链”字都删除了，变成了作用域，但是还没有看前面作用域相关内容，应该有新的理解，在完成翻译后再继续补全。 ","date":"2020-12-24","objectID":"/posts/%E9%80%9A%E8%BF%87%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-undefined/:6:0","tags":["JavaScript"],"title":"通过变量作用域深入了解 undefined","uri":"/posts/%E9%80%9A%E8%BF%87%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-undefined/"},{"categories":["Frontend"],"content":"今天刚开始学习【重学前端】的课程，讲到装箱转换的时候提到了函数的 call 方法，而 call 方法在我的印象中就只有 call 约等于 apply ，然后就再没有然后了。在我想深入了解下 call 方法的时候又发现了有人在同时讲解原型，带着各种心情赶紧学习下到底什么是原型和原型链。 ","date":"2020-12-15","objectID":"/posts/javascript-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/:0:0","tags":["JavaScript"],"title":"JavaScript 原型和原型链","uri":"/posts/javascript-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"categories":["Frontend"],"content":"原型 prototype [ˈproʊtətaɪp] 原型 下面这个图很多大神都有画过，记录下我自己的理解和实验。 ","date":"2020-12-15","objectID":"/posts/javascript-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/:1:0","tags":["JavaScript"],"title":"JavaScript 原型和原型链","uri":"/posts/javascript-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"categories":["Frontend"],"content":"构造函数视角 函数可以用来做构造器，也就是 constructor，而构造器也可以称为类。 通过构造器 Apple 来创建一个对象对象 apple。 构造函数创建了实例对象，这是构造函数与实例对象的关系。 构造函数有一个属性叫做 propotype，他指向了原型对象。 这里的原型对象写做 [[propotype]]，这里我猜测是为了区分 propotype 的属性。 现在我知道了，原来这里两个中括号是 ECMA 文档中的书写方式。 ","date":"2020-12-15","objectID":"/posts/javascript-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/:1:1","tags":["JavaScript"],"title":"JavaScript 原型和原型链","uri":"/posts/javascript-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"categories":["Frontend"],"content":"原型对象视角 原型对象的 constructor 属性指向了构造函数。 这里用构造器的原型对象的 constructor 方法来创建一个 badApple ，会发现它和 apple 的类型是相等的。 ","date":"2020-12-15","objectID":"/posts/javascript-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/:1:2","tags":["JavaScript"],"title":"JavaScript 原型和原型链","uri":"/posts/javascript-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"categories":["Frontend"],"content":"实例对象视角 对象也有一个属性 _propo_，这是一个隐式属性，**对象的 _propo_ 指向了他的构造函数的原型对象。**也就是说 Apple 的 propotype 属性和 apple、badApple 的 _propo_ 指向了同一个地址。 ","date":"2020-12-15","objectID":"/posts/javascript-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/:1:3","tags":["JavaScript"],"title":"JavaScript 原型和原型链","uri":"/posts/javascript-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"categories":["Frontend"],"content":"由函数引出原型链 函数是 JS 中的第一类对象，在 Javascript 中，对象所拥有的函数也同样拥有，也就是说构造函数 Apple 也同样会有 _propo_ 属性去指向他的父类的原型对象，为了理清这乱七八糟的关系，就有了下面“对象-函数-构造函数-实例对象”这样的一个关系图，也就是原型链图。 ","date":"2020-12-15","objectID":"/posts/javascript-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/:1:4","tags":["JavaScript"],"title":"JavaScript 原型和原型链","uri":"/posts/javascript-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"categories":["Frontend"],"content":"原型链 原型链\" 原型链 这张图理解了上面的内容之后就感觉容易多了，总结一下有以下几点需要注意。 任何函数的父类都是 Function 构造函数，也就是任何函数的 _proto_ 指向 Function.prototype，这里同样包含了 Function 构造函数自己。 Object 构造函数它也是函数，它的的 _proto_ 也指向 Function.prototype。 Function.prototype 的 _proto_ 指向 Object.prototype，这也就是为什么说函数也是对象。 Object.prototype 的 _proto_ 是 null。 ## ES6 中的类 类的写法也是由原型运行时来承载的，逻辑上 JavaScript 认为每个类是有共同原型的一组对象，类中定义的方法和属性会被卸载原型对象之上。此外最重要的是类提供了继承能力。 class Animal { constructor(name) { this.name = name; } speak() { console.log(this.name + ' makes a noise.'); } } class Dog extends Animal { constructor(name) { super(name); // call the super class constructor and pass in the name parameter  } speak() { console.log(this.name + ' barks.'); } } let d = new Dog('Mitzie'); d.speak(); // Mitzie barks. 以上代码创造了 Animal 类，并且通过 extends 关键字让 Dog 继承了它，展示了最终调用子类的 speak 方法获取了父类的 name。比起早期的原型模拟方式，使用 extends 关键字自动设置了 constructor，并且会自动调用父类的构造函数，这是一种更少坑的设计。所以当我们使用类的思想来设计代码时，应该尽量使用 class 来声明类，而不是用旧语法，拿函数来模拟对象。 super 关键字用于访问和调用一个对象的父对象上的函数。 在构造函数中使用时，super 关键字将单独出现，并且必须在使用this关键字之前使用。 super([arguments]); // 调用 父对象/父类 的构造函数 super.functionOnParent([arguments]); // 调用 父对象/父类 上的方法 ","date":"2020-12-15","objectID":"/posts/javascript-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/:2:0","tags":["JavaScript"],"title":"JavaScript 原型和原型链","uri":"/posts/javascript-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"}]