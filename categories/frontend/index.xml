<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Frontend - Category - Ten's Blog</title><link>https://blog.okten.cn/categories/frontend/</link><description>Frontend - Category - Ten's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>li.tw.ten@gmail.com (Ten Li)</managingEditor><webMaster>li.tw.ten@gmail.com (Ten Li)</webMaster><lastBuildDate>Mon, 27 Jun 2022 13:36:22 +0800</lastBuildDate><atom:link href="https://blog.okten.cn/categories/frontend/" rel="self" type="application/rss+xml"/><item><title>在 angular 的 library 中添加静态 XML 作为静态 HTML 渲染</title><link>https://blog.okten.cn/posts/%E5%9C%A8-angular-%E7%9A%84-library-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81-xml-%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81-html-%E6%B8%B2%E6%9F%93/</link><pubDate>Mon, 27 Jun 2022 13:36:22 +0800</pubDate><author>Ten Li</author><guid>https://blog.okten.cn/posts/%E5%9C%A8-angular-%E7%9A%84-library-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81-xml-%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81-html-%E6%B8%B2%E6%9F%93/</guid><description>在当前项目中 End User License Agreement 是一个静态 XML 文件，在打包在了根目录下直接通过 Angular JS 渲染。 本次开发是升级这个应用为 Angular，并且将其以 Library 的形式引入公司</description></item><item><title>TypeScript 补漏</title><link>https://blog.okten.cn/posts/typescript/</link><pubDate>Fri, 07 May 2021 18:06:39 +0800</pubDate><author>Ten Li</author><guid>https://blog.okten.cn/posts/typescript/</guid><description><![CDATA[TypeScript 基础 函数签名和重载 Signature Overloading function contactPeople(method: &#34;email&#34;, ...people: HasEmail[]): void; function contactPeople(method: &#34;phone&#34;, ...people: HasPhoneNumber[]): void; function contactPeople(method: &#34;email&#34; | &#34;phone&#34;, ...people: (HasEmail | HasPhoneNumber)[]): void { } 词法作用域 Lexical Scope TODO Interfaces 和 type aliases TODO 泛型 Generics 泛型使用 interface WrappedValue&lt;T&gt; { value: T; } let val: WrappedValue&lt;string[]&gt; = { value: [] };]]></description></item><item><title>Angular 中 RXJS 的应用</title><link>https://blog.okten.cn/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/</link><pubDate>Thu, 08 Apr 2021 18:03:02 +0800</pubDate><author>Ten Li</author><guid>https://blog.okten.cn/posts/angular-%E4%B8%AD-rxjs-%E7%9A%84%E5%BA%94%E7%94%A8/</guid><description>跟随 Acme Product Management 工程来理解 RxJS 在 Angular 中的响应式编程。 初步接触 Reactive 在 Angular 的使用中，我们常常使用编程式模式（procedural pattern）实现从后端服务</description></item><item><title>ng-fundamentals 基础内容查缺补漏</title><link>https://blog.okten.cn/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/</link><pubDate>Mon, 05 Apr 2021 10:51:21 +0800</pubDate><author>Ten Li</author><guid>https://blog.okten.cn/posts/ng-fundamentals-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/</guid><description><![CDATA[组件 @Component({ selector: &#39;events-app&#39;, template: ` &lt;h2&gt;Hello world&lt;/h2&gt; &lt;img src=&#34;https://blog.okten.cn/assets/images/basic-shield.png&#34;/&gt; ` }) 资源路径相对于 index.html，不能使用静态路径访问文件。 webpack 需要在编译 app 时知道哪一个文件要被捆绑，在 angular.json 中设置：]]></description></item><item><title>Angular 中的 DI</title><link>https://blog.okten.cn/posts/angular-%E4%B8%AD%E7%9A%84-di/</link><pubDate>Thu, 25 Mar 2021 18:28:34 +0800</pubDate><author>Ten Li</author><guid>https://blog.okten.cn/posts/angular-%E4%B8%AD%E7%9A%84-di/</guid><description>我们都知道创建一个服务，并通过 @Injectable 装饰器或者在 Module 中的 providers 中注册，并在组件的构造方法中通过如下方式依赖注入： import { AuthService } from &amp;#39;../user/auth.service&amp;#39;; export class NavBarComponent { constructor(public auth:AuthService){ } } 首先，必须</description></item><item><title>Angular 变更检测——它到底是如何工作的？</title><link>https://blog.okten.cn/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</link><pubDate>Tue, 23 Mar 2021 19:41:26 +0800</pubDate><author>Ten Li</author><guid>https://blog.okten.cn/posts/angular-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</guid><description>原文：Angular Change Detection - How Does It Really Work? 与 AngularJs 中的等效方法相比，Angular 变更检测机制更加透明且易于推理。但是，在某些情况下（例如进行性能优化</description></item><item><title>JS Promise States and Fates</title><link>https://blog.okten.cn/posts/states-and-fates/</link><pubDate>Wed, 10 Feb 2021 20:57:40 +0800</pubDate><author>Ten Li</author><guid>https://blog.okten.cn/posts/states-and-fates/</guid><description>This document helps clarify the different adjectives surrounding promises, by dividing them up into two categories: states and fates. 本文档阐明围绕 Promise 的各种形容词，把它们分为两部分：状态和命运。 States Promises have three possible mutually exclusive states: fulfilled, rejected, and pending. Promise 有三种可能的互斥</description></item><item><title>JavaScript 深浅拷贝</title><link>https://blog.okten.cn/posts/javascript-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</link><pubDate>Thu, 04 Feb 2021 21:39:37 +0800</pubDate><author>Ten Li</author><guid>https://blog.okten.cn/posts/javascript-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</guid><description>在数组章节提到数组的展开运算符时，作者举例说明展开运算符可以进行拷贝，原为如下： The spread operator is a convenient way to create a (shallow) copy of an array: let original = [1,2,3]; let copy = [...original]; copy[0] = 0; // Modifying the copy</description></item><item><title>通过函数声明和调用掌握函数的 this 值</title><link>https://blog.okten.cn/posts/%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%92%8C%E8%B0%83%E7%94%A8%E6%8E%8C%E6%8F%A1%E5%87%BD%E6%95%B0%E7%9A%84-this-%E5%80%BC/</link><pubDate>Sat, 16 Jan 2021 10:15:20 +0800</pubDate><author>Ten Li</author><guid>https://blog.okten.cn/posts/%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%92%8C%E8%B0%83%E7%94%A8%E6%8E%8C%E6%8F%A1%E5%87%BD%E6%95%B0%E7%9A%84-this-%E5%80%BC/</guid><description>函数的 this 对于基础薄弱的前端程序员一直是一个比较头疼的问题，在对 ES6 的模糊和对 ES6 之前的函数作用域不理解双重打击下，往往无法区分 this 值到底是什么，因</description></item><item><title>通过变量作用域深入了解 undefined</title><link>https://blog.okten.cn/posts/%E9%80%9A%E8%BF%87%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-undefined/</link><pubDate>Thu, 24 Dec 2020 21:57:44 +0800</pubDate><author>Ten Li</author><guid>https://blog.okten.cn/posts/%E9%80%9A%E8%BF%87%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-undefined/</guid><description>undefined 是一个变量，它有可能被篡改，所以使用void（0）来代替他，但是在做实验的时候发现虽然给它赋值不报错，取值时候 undefined 却并没有改变。 undefined = 0 // 0 undefined</description></item></channel></rss>