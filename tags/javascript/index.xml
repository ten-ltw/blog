<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>JavaScript - Tag - Ten's Blog</title><link>https://blog.okten.cn/tags/javascript/</link><description>JavaScript - Tag - Ten's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>li.tw.ten@gmail.com (Ten Li)</managingEditor><webMaster>li.tw.ten@gmail.com (Ten Li)</webMaster><lastBuildDate>Wed, 10 Feb 2021 20:57:40 +0800</lastBuildDate><atom:link href="https://blog.okten.cn/tags/javascript/" rel="self" type="application/rss+xml"/><item><title>JS Promise States and Fates</title><link>https://blog.okten.cn/posts/states-and-fates/</link><pubDate>Wed, 10 Feb 2021 20:57:40 +0800</pubDate><author>Ten Li</author><guid>https://blog.okten.cn/posts/states-and-fates/</guid><description>This document helps clarify the different adjectives surrounding promises, by dividing them up into two categories: states and fates. 本文档阐明围绕 Promise 的各种形容词，把它们分为两部分：状态和命运。 States Promises have three possible mutually exclusive states: fulfilled, rejected, and pending. Promise 有三种可能的互斥</description></item><item><title>JavaScript 深浅拷贝</title><link>https://blog.okten.cn/posts/javascript-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</link><pubDate>Thu, 04 Feb 2021 21:39:37 +0800</pubDate><author>Ten Li</author><guid>https://blog.okten.cn/posts/javascript-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</guid><description>在数组章节提到数组的展开运算符时，作者举例说明展开运算符可以进行拷贝，原为如下： The spread operator is a convenient way to create a (shallow) copy of an array: let original = [1,2,3]; let copy = [...original]; copy[0] = 0; // Modifying the copy</description></item><item><title>通过函数声明和调用掌握函数的 this 值</title><link>https://blog.okten.cn/posts/%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%92%8C%E8%B0%83%E7%94%A8%E6%8E%8C%E6%8F%A1%E5%87%BD%E6%95%B0%E7%9A%84-this-%E5%80%BC/</link><pubDate>Sat, 16 Jan 2021 10:15:20 +0800</pubDate><author>Ten Li</author><guid>https://blog.okten.cn/posts/%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%92%8C%E8%B0%83%E7%94%A8%E6%8E%8C%E6%8F%A1%E5%87%BD%E6%95%B0%E7%9A%84-this-%E5%80%BC/</guid><description>函数的 this 对于基础薄弱的前端程序员一直是一个比较头疼的问题，在对 ES6 的模糊和对 ES6 之前的函数作用域不理解双重打击下，往往无法区分 this 值到底是什么，因</description></item><item><title>通过变量作用域深入了解 undefined</title><link>https://blog.okten.cn/posts/%E9%80%9A%E8%BF%87%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-undefined/</link><pubDate>Thu, 24 Dec 2020 21:57:44 +0800</pubDate><author>Ten Li</author><guid>https://blog.okten.cn/posts/%E9%80%9A%E8%BF%87%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-undefined/</guid><description>undefined 是一个变量，它有可能被篡改，所以使用void（0）来代替他，但是在做实验的时候发现虽然给它赋值不报错，取值时候 undefined 却并没有改变。 undefined = 0 // 0 undefined</description></item><item><title>JavaScript 原型和原型链</title><link>https://blog.okten.cn/posts/javascript-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</link><pubDate>Tue, 15 Dec 2020 19:37:33 +0800</pubDate><author>Ten Li</author><guid>https://blog.okten.cn/posts/javascript-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</guid><description>今天刚开始学习【重学前端】的课程，讲到装箱转换的时候提到了函数的 call 方法，而 call 方法在我的印象中就只有 call 约等于 apply ，然后就再没有然后了。在我想深入</description></item></channel></rss>